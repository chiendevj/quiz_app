"use strict";

function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@jridgewell/trace-mapping'), require('@jridgewell/gen-mapping')) : typeof define === 'function' && define.amd ? define(['@jridgewell/trace-mapping', '@jridgewell/gen-mapping'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));
})(void 0, function (traceMapping, genMapping) {
  'use strict';

  var SOURCELESS_MAPPING = /* #__PURE__ */SegmentObject('', -1, -1, '', null, false);
  var EMPTY_SOURCES = [];
  function SegmentObject(source, line, column, name, content, ignore) {
    return {
      source: source,
      line: line,
      column: column,
      name: name,
      content: content,
      ignore: ignore
    };
  }
  function Source(map, sources, source, content, ignore) {
    return {
      map: map,
      sources: sources,
      source: source,
      content: content,
      ignore: ignore
    };
  }
  /**
   * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes
   * (which may themselves be SourceMapTrees).
   */
  function MapSource(map, sources) {
    return Source(map, sources, '', null, false);
  }
  /**
   * A "leaf" node in the sourcemap tree, representing an original, unmodified source file. Recursive
   * segment tracing ends at the `OriginalSource`.
   */
  function OriginalSource(source, content, ignore) {
    return Source(null, EMPTY_SOURCES, source, content, ignore);
  }
  /**
   * traceMappings is only called on the root level SourceMapTree, and begins the process of
   * resolving each mapping in terms of the original source files.
   */
  function traceMappings(tree) {
    // TODO: Eventually support sourceRoot, which has to be removed because the sources are already
    // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.
    var gen = new genMapping.GenMapping({
      file: tree.map.file
    });
    var rootSources = tree.sources,
      map = tree.map;
    var rootNames = map.names;
    var rootMappings = traceMapping.decodedMappings(map);
    for (var i = 0; i < rootMappings.length; i++) {
      var segments = rootMappings[i];
      for (var j = 0; j < segments.length; j++) {
        var segment = segments[j];
        var genCol = segment[0];
        var traced = SOURCELESS_MAPPING;
        // 1-length segments only move the current generated column, there's no source information
        // to gather from it.
        if (segment.length !== 1) {
          var _source = rootSources[segment[1]];
          traced = originalPositionFor(_source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');
          // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a
          // respective segment into an original source.
          if (traced == null) continue;
        }
        var _traced = traced,
          column = _traced.column,
          line = _traced.line,
          name = _traced.name,
          content = _traced.content,
          source = _traced.source,
          ignore = _traced.ignore;
        genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name);
        if (source && content != null) genMapping.setSourceContent(gen, source, content);
        if (ignore) genMapping.setIgnore(gen, source, true);
      }
    }
    return gen;
  }
  /**
   * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own
   * child SourceMapTrees, until we find the original source map.
   */
  function originalPositionFor(source, line, column, name) {
    if (!source.map) {
      return SegmentObject(source.source, line, column, name, source.content, source.ignore);
    }
    var segment = traceMapping.traceSegment(source.map, line, column);
    // If we couldn't find a segment, then this doesn't exist in the sourcemap.
    if (segment == null) return null;
    // 1-length segments only move the current generated column, there's no source information
    // to gather from it.
    if (segment.length === 1) return SOURCELESS_MAPPING;
    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
  }
  function asArray(value) {
    if (Array.isArray(value)) return value;
    return [value];
  }
  /**
   * Recursively builds a tree structure out of sourcemap files, with each node
   * being either an `OriginalSource` "leaf" or a `SourceMapTree` composed of
   * `OriginalSource`s and `SourceMapTree`s.
   *
   * Every sourcemap is composed of a collection of source files and mappings
   * into locations of those source files. When we generate a `SourceMapTree` for
   * the sourcemap, we attempt to load each source file's own sourcemap. If it
   * does not have an associated sourcemap, it is considered an original,
   * unmodified source file.
   */
  function buildSourceMapTree(input, loader) {
    var maps = asArray(input).map(function (m) {
      return new traceMapping.TraceMap(m, '');
    });
    var map = maps.pop();
    for (var i = 0; i < maps.length; i++) {
      if (maps[i].sources.length > 1) {
        throw new Error("Transformation map ".concat(i, " must have exactly one source file.\n") + 'Did you specify these with the most recent transformation maps first?');
      }
    }
    var tree = build(map, loader, '', 0);
    for (var _i = maps.length - 1; _i >= 0; _i--) {
      tree = MapSource(maps[_i], [tree]);
    }
    return tree;
  }
  function build(map, loader, importer, importerDepth) {
    var resolvedSources = map.resolvedSources,
      sourcesContent = map.sourcesContent,
      ignoreList = map.ignoreList;
    var depth = importerDepth + 1;
    var children = resolvedSources.map(function (sourceFile, i) {
      // The loading context gives the loader more information about why this file is being loaded
      // (eg, from which importer). It also allows the loader to override the location of the loaded
      // sourcemap/original source, or to override the content in the sourcesContent field if it's
      // an unmodified source file.
      var ctx = {
        importer: importer,
        depth: depth,
        source: sourceFile || '',
        content: undefined,
        ignore: undefined
      };
      // Use the provided loader callback to retrieve the file's sourcemap.
      // TODO: We should eventually support async loading of sourcemap files.
      var sourceMap = loader(ctx.source, ctx);
      var source = ctx.source,
        content = ctx.content,
        ignore = ctx.ignore;
      // If there is a sourcemap, then we need to recurse into it to load its source files.
      if (sourceMap) return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);
      // Else, it's an unmodified source file.
      // The contents of this unmodified source file can be overridden via the loader context,
      // allowing it to be explicitly null or a string. If it remains undefined, we fall back to
      // the importing sourcemap's `sourcesContent` field.
      var sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;
      var ignored = ignore !== undefined ? ignore : ignoreList ? ignoreList.includes(i) : false;
      return OriginalSource(source, sourceContent, ignored);
    });
    return MapSource(map, children);
  }

  /**
   * A SourceMap v3 compatible sourcemap, which only includes fields that were
   * provided to it.
   */
  var SourceMap = /*#__PURE__*/function () {
    function SourceMap(map, options) {
      _classCallCheck(this, SourceMap);
      var out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
      this.version = out.version; // SourceMap spec says this should be first.
      this.file = out.file;
      this.mappings = out.mappings;
      this.names = out.names;
      this.ignoreList = out.ignoreList;
      this.sourceRoot = out.sourceRoot;
      this.sources = out.sources;
      if (!options.excludeContent) {
        this.sourcesContent = out.sourcesContent;
      }
    }
    return _createClass(SourceMap, [{
      key: "toString",
      value: function toString() {
        return JSON.stringify(this);
      }
    }]);
  }();
  /**
   * Traces through all the mappings in the root sourcemap, through the sources
   * (and their sourcemaps), all the way back to the original source location.
   *
   * `loader` will be called every time we encounter a source file. If it returns
   * a sourcemap, we will recurse into that sourcemap to continue the trace. If
   * it returns a falsey value, that source file is treated as an original,
   * unmodified source file.
   *
   * Pass `excludeContent` to exclude any self-containing source file content
   * from the output sourcemap.
   *
   * Pass `decodedMappings` to receive a SourceMap with decoded (instead of
   * VLQ encoded) mappings.
   */
  function remapping(input, loader, options) {
    var opts = _typeof(options) === 'object' ? options : {
      excludeContent: !!options,
      decodedMappings: false
    };
    var tree = buildSourceMapTree(input, loader);
    return new SourceMap(traceMappings(tree), opts);
  }
  return remapping;
});