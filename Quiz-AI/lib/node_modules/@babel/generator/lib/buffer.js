"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var Buffer = /*#__PURE__*/function () {
  function Buffer(map, indentChar) {
    _classCallCheck(this, Buffer);
    this._map = null;
    this._buf = "";
    this._str = "";
    this._appendCount = 0;
    this._last = 0;
    this._queue = [];
    this._queueCursor = 0;
    this._canMarkIdName = true;
    this._indentChar = "";
    this._fastIndentations = [];
    this._position = {
      line: 1,
      column: 0
    };
    this._sourcePosition = {
      identifierName: undefined,
      identifierNamePos: undefined,
      line: undefined,
      column: undefined,
      filename: undefined
    };
    this._map = map;
    this._indentChar = indentChar;
    for (var i = 0; i < 64; i++) {
      this._fastIndentations.push(indentChar.repeat(i));
    }
    this._allocQueue();
  }
  return _createClass(Buffer, [{
    key: "_allocQueue",
    value: function _allocQueue() {
      var queue = this._queue;
      for (var i = 0; i < 16; i++) {
        queue.push({
          "char": 0,
          repeat: 1,
          line: undefined,
          column: undefined,
          identifierName: undefined,
          identifierNamePos: undefined,
          filename: ""
        });
      }
    }
  }, {
    key: "_pushQueue",
    value: function _pushQueue(_char, repeat, line, column, filename) {
      var cursor = this._queueCursor;
      if (cursor === this._queue.length) {
        this._allocQueue();
      }
      var item = this._queue[cursor];
      item["char"] = _char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.filename = filename;
      this._queueCursor++;
    }
  }, {
    key: "_popQueue",
    value: function _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }
      return this._queue[--this._queueCursor];
    }
  }, {
    key: "get",
    value: function get() {
      this._flush();
      var map = this._map;
      var result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? void 0 : map.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          var resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },
        set map(value) {
          Object.defineProperty(result, "map", {
            value: value,
            writable: true
          });
        },
        get rawMappings() {
          var mappings = map == null ? void 0 : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },
        set rawMappings(value) {
          Object.defineProperty(result, "rawMappings", {
            value: value,
            writable: true
          });
        }
      };
      return result;
    }
  }, {
    key: "append",
    value: function append(str, maybeNewline) {
      this._flush();
      this._append(str, this._sourcePosition, maybeNewline);
    }
  }, {
    key: "appendChar",
    value: function appendChar(_char2) {
      this._flush();
      this._appendChar(_char2, 1, this._sourcePosition);
    }
  }, {
    key: "queue",
    value: function queue(_char3) {
      if (_char3 === 10) {
        while (this._queueCursor !== 0) {
          var _char4 = this._queue[this._queueCursor - 1]["char"];
          if (_char4 !== 32 && _char4 !== 9) {
            break;
          }
          this._queueCursor--;
        }
      }
      var sourcePosition = this._sourcePosition;
      this._pushQueue(_char3, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    }
  }, {
    key: "queueIndentation",
    value: function queueIndentation(repeat) {
      if (repeat === 0) return;
      this._pushQueue(-1, repeat, undefined, undefined, undefined);
    }
  }, {
    key: "_flush",
    value: function _flush() {
      var queueCursor = this._queueCursor;
      var queue = this._queue;
      for (var i = 0; i < queueCursor; i++) {
        var item = queue[i];
        this._appendChar(item["char"], item.repeat, item);
      }
      this._queueCursor = 0;
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(_char5, repeat, sourcePos) {
      this._last = _char5;
      if (_char5 === -1) {
        var fastIndentation = this._fastIndentations[repeat];
        if (fastIndentation !== undefined) {
          this._str += fastIndentation;
        } else {
          this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        }
      } else {
        this._str += repeat > 1 ? String.fromCharCode(_char5).repeat(repeat) : String.fromCharCode(_char5);
      }
      if (_char5 !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
      if (this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
    }
  }, {
    key: "_append",
    value: function _append(str, sourcePos, maybeNewline) {
      var len = str.length;
      var position = this._position;
      this._last = str.charCodeAt(len - 1);
      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }
      if (!maybeNewline && !this._map) {
        position.column += len;
        return;
      }
      var column = sourcePos.column,
        identifierName = sourcePos.identifierName,
        identifierNamePos = sourcePos.identifierNamePos,
        filename = sourcePos.filename;
      var line = sourcePos.line;
      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      var i = str.indexOf("\n");
      var last = 0;
      if (i !== 0) {
        this._mark(line, column, identifierName, identifierNamePos, filename);
      }
      while (i !== -1) {
        position.line++;
        position.column = 0;
        last = i + 1;
        if (last < len && line !== undefined) {
          this._mark(++line, 0, null, null, filename);
        }
        i = str.indexOf("\n", last);
      }
      position.column += len - last;
    }
  }, {
    key: "_mark",
    value: function _mark(line, column, identifierName, identifierNamePos, filename) {
      var _this$_map;
      (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    }
  }, {
    key: "removeTrailingNewline",
    value: function removeTrailingNewline() {
      var queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 10) {
        this._queueCursor--;
      }
    }
  }, {
    key: "removeLastSemicolon",
    value: function removeLastSemicolon() {
      var queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 59) {
        this._queueCursor--;
      }
    }
  }, {
    key: "getLastChar",
    value: function getLastChar() {
      var queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1]["char"] : this._last;
    }
  }, {
    key: "getNewlineCount",
    value: function getNewlineCount() {
      var queueCursor = this._queueCursor;
      var count = 0;
      if (queueCursor === 0) return this._last === 10 ? 1 : 0;
      for (var i = queueCursor - 1; i >= 0; i--) {
        if (this._queue[i]["char"] !== 10) {
          break;
        }
        count++;
      }
      return count === queueCursor && this._last === 10 ? count + 1 : count;
    }
  }, {
    key: "endsWithCharAndNewline",
    value: function endsWithCharAndNewline() {
      var queue = this._queue;
      var queueCursor = this._queueCursor;
      if (queueCursor !== 0) {
        var lastCp = queue[queueCursor - 1]["char"];
        if (lastCp !== 10) return;
        if (queueCursor > 1) {
          return queue[queueCursor - 2]["char"];
        } else {
          return this._last;
        }
      }
    }
  }, {
    key: "hasContent",
    value: function hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
  }, {
    key: "exactSource",
    value: function exactSource(loc, cb) {
      if (!this._map) {
        cb();
        return;
      }
      this.source("start", loc);
      var identifierName = loc.identifierName;
      var sourcePos = this._sourcePosition;
      if (identifierName) {
        this._canMarkIdName = false;
        sourcePos.identifierName = identifierName;
      }
      cb();
      if (identifierName) {
        this._canMarkIdName = true;
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      this.source("end", loc);
    }
  }, {
    key: "source",
    value: function source(prop, loc) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, 0);
    }
  }, {
    key: "sourceWithOffset",
    value: function sourceWithOffset(prop, loc, columnOffset) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, columnOffset);
    }
  }, {
    key: "withSource",
    value: function withSource(prop, loc, cb) {
      if (this._map) {
        this.source(prop, loc);
      }
      cb();
    }
  }, {
    key: "_normalizePosition",
    value: function _normalizePosition(prop, loc, columnOffset) {
      var pos = loc[prop];
      var target = this._sourcePosition;
      if (pos) {
        target.line = pos.line;
        target.column = Math.max(pos.column + columnOffset, 0);
        target.filename = loc.filename;
      }
    }
  }, {
    key: "getCurrentColumn",
    value: function getCurrentColumn() {
      var queue = this._queue;
      var queueCursor = this._queueCursor;
      var lastIndex = -1;
      var len = 0;
      for (var i = 0; i < queueCursor; i++) {
        var item = queue[i];
        if (item["char"] === 10) {
          lastIndex = len;
        }
        len += item.repeat;
      }
      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    }
  }, {
    key: "getCurrentLine",
    value: function getCurrentLine() {
      var count = 0;
      var queue = this._queue;
      for (var i = 0; i < this._queueCursor; i++) {
        if (queue[i]["char"] === 10) {
          count++;
        }
      }
      return this._position.line + count;
    }
  }]);
}();
exports["default"] = Buffer;