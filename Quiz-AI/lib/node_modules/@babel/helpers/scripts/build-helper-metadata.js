"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHelperMetadata = getHelperMetadata;
exports.stringifyMetadata = stringifyMetadata;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// NOTE: This file must be compatible with old Node.js versions, since it runs
// during testing.

/**
 * @typedef {Object} HelperMetadata
 * @property {string[]} globals
 * @property {{ [name: string]: string[] }} locals
 * @property {{ [name: string]: string[] }} dependencies
 * @property {string[]} exportBindingAssignments
 * @property {string} exportName
 */

/**
 * Given a file AST for a given helper, get a bunch of metadata about it so that Babel can quickly render
 * the helper is whatever context it is needed in.
 *
 * @param {typeof import("@babel/core")} babel
 *
 * @returns {HelperMetadata}
 */
function getHelperMetadata(babel, code, helperName) {
  var globals = new Set();
  // Maps imported identifier name -> helper name
  var dependenciesBindings = new Map();
  var exportName;
  var exportBindingAssignments = [];
  // helper name -> reference paths
  var dependencies = new Map();
  // local variable name -> reference paths
  var locals = new Map();
  var spansToRemove = [];
  var validateDefaultExport = function validateDefaultExport(decl) {
    if (exportName) {
      throw new Error("Helpers can have only one default export (in ".concat(helperName, ")"));
    }
    if (!decl.isFunctionDeclaration() || !decl.node.id) {
      throw new Error("Helpers can only export named function declarations (in ".concat(helperName, ")"));
    }
  };

  /** @type {import("@babel/traverse").Visitor} */
  var dependencyVisitor = {
    Program: function Program(path) {
      var _iterator = _createForOfIteratorHelper(path.get("body")),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          if (child.isImportDeclaration()) {
            if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
              throw new Error("Helpers can only import a default value (in ".concat(helperName, ")"));
            }
            dependenciesBindings.set(child.node.specifiers[0].local.name, child.node.source.value);
            dependencies.set(child.node.source.value, []);
            spansToRemove.push([child.node.start, child.node.end]);
            child.remove();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(path.get("body")),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _child = _step2.value;
          if (_child.isExportDefaultDeclaration()) {
            var decl = _child.get("declaration");
            validateDefaultExport(decl);
            exportName = decl.node.id.name;
            spansToRemove.push([_child.node.start, decl.node.start]);
            _child.replaceWith(decl.node);
          } else if (_child.isExportNamedDeclaration() && _child.node.specifiers.length === 1 && _child.get("specifiers.0.exported").isIdentifier({
            name: "default"
          })) {
            var name = _child.node.specifiers[0].local.name;
            validateDefaultExport(_child.scope.getBinding(name).path);
            exportName = name;
            spansToRemove.push([_child.node.start, _child.node.end]);
            _child.remove();
          } else if (_child.isExportAllDeclaration() || _child.isExportNamedDeclaration()) {
            throw new Error("Helpers can only export default (in ".concat(helperName, ")"));
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      path.scope.crawl();
      var bindings = path.scope.getAllBindings();
      Object.keys(bindings).forEach(function (name) {
        if (dependencies.has(name)) return;
        var binding = bindings[name];
        var references = [].concat(_toConsumableArray(binding.path.getBindingIdentifierPaths(true)[name].map(makePath)), _toConsumableArray(binding.referencePaths.map(makePath)));
        var _iterator3 = _createForOfIteratorHelper(binding.constantViolations),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var violation = _step3.value;
            violation.getBindingIdentifierPaths(true)[name].forEach(function (path) {
              references.push(makePath(path));
            });
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        locals.set(name, references);
      });
    },
    ReferencedIdentifier: function ReferencedIdentifier(child) {
      var name = child.node.name;
      var binding = child.scope.getBinding(name);
      if (!binding) {
        if (dependenciesBindings.has(name)) {
          dependencies.get(dependenciesBindings.get(name)).push(makePath(child));
        } else if (name !== "arguments" || child.scope.path.isProgram()) {
          globals.add(name);
        }
      }
    },
    AssignmentExpression: function AssignmentExpression(child) {
      var left = child.get("left");
      if (!(exportName in left.getBindingIdentifiers())) return;
      if (!left.isIdentifier()) {
        throw new Error("Only simple assignments to exports are allowed in helpers (in ".concat(helperName, ")"));
      }
      var binding = child.scope.getBinding(exportName);
      if (binding && binding.scope.path.isProgram()) {
        exportBindingAssignments.push(makePath(child));
      }
    }
  };
  babel.transformSync(code, {
    configFile: false,
    babelrc: false,
    plugins: [function () {
      return {
        visitor: dependencyVisitor
      };
    }]
  });
  if (!exportName) throw new Error("Helpers must have a named default export.");

  // Process these in reverse so that mutating the references does not invalidate any later paths in
  // the list.
  exportBindingAssignments.reverse();
  spansToRemove.sort(function (_ref, _ref2) {
    var _ref3 = _slicedToArray(_ref, 1),
      start1 = _ref3[0];
    var _ref4 = _slicedToArray(_ref2, 1),
      start2 = _ref4[0];
    return start2 - start1;
  });
  for (var _i = 0, _spansToRemove = spansToRemove; _i < _spansToRemove.length; _i++) {
    var _spansToRemove$_i = _slicedToArray(_spansToRemove[_i], 2),
      start = _spansToRemove$_i[0],
      end = _spansToRemove$_i[1];
    code = code.slice(0, start) + code.slice(end);
  }
  return [code, {
    globals: Array.from(globals),
    locals: Object.fromEntries(locals),
    dependencies: Object.fromEntries(dependencies),
    exportBindingAssignments: exportBindingAssignments,
    exportName: exportName
  }];
}
function makePath(path) {
  var parts = [];
  for (; path.parentPath; path = path.parentPath) {
    parts.push(path.key);
    if (path.inList) parts.push(path.listKey);
  }
  return parts.reverse().join(".");
}
function stringifyMetadata(metadata) {
  return "    {\n      globals: ".concat(JSON.stringify(metadata.globals), ",\n      locals: ").concat(JSON.stringify(metadata.locals), ",\n      exportBindingAssignments: ").concat(JSON.stringify(metadata.exportBindingAssignments), ",\n      exportName: ").concat(JSON.stringify(metadata.exportName), ",\n      dependencies: ").concat(JSON.stringify(metadata.dependencies), ",\n    }\n  ");
}