"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.get = get;
exports.getDependencies = getDependencies;
exports.list = void 0;
exports.minVersion = minVersion;
var _t = require("@babel/types");
var _helpersGenerated = require("./helpers-generated.js");
var cloneNode = _t.cloneNode,
  identifier = _t.identifier;
function deep(obj, path, value) {
  try {
    var parts = path.split(".");
    var last = parts.shift();
    while (parts.length > 0) {
      obj = obj[last];
      last = parts.shift();
    }
    if (arguments.length > 2) {
      obj[last] = value;
    } else {
      return obj[last];
    }
  } catch (e) {
    e.message += " (when accessing ".concat(path, ")");
    throw e;
  }
}
function permuteHelperAST(ast, metadata, bindingName, localBindings, getDependency, adjustAst) {
  var locals = metadata.locals,
    dependencies = metadata.dependencies,
    exportBindingAssignments = metadata.exportBindingAssignments,
    exportName = metadata.exportName;
  var bindings = new Set(localBindings || []);
  if (bindingName) bindings.add(bindingName);
  var _iterator = _createForOfIteratorHelper((Object.entries || function (o) {
      return Object.keys(o).map(function (k) {
        return [k, o[k]];
      });
    })(locals)),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        name = _step$value[0],
        paths = _step$value[1];
      var newName = name;
      if (bindingName && name === exportName) {
        newName = bindingName;
      } else {
        while (bindings.has(newName)) newName = "_" + newName;
      }
      if (newName !== name) {
        var _iterator3 = _createForOfIteratorHelper(paths),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var path = _step3.value;
            deep(ast, path, identifier(newName));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _iterator2 = _createForOfIteratorHelper((Object.entries || function (o) {
      return Object.keys(o).map(function (k) {
        return [k, o[k]];
      });
    })(dependencies)),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        _name = _step2$value[0],
        _paths = _step2$value[1];
      var ref = typeof getDependency === "function" && getDependency(_name) || identifier(_name);
      var _iterator4 = _createForOfIteratorHelper(_paths),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _path = _step4.value;
          deep(ast, _path, cloneNode(ref));
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  adjustAst == null || adjustAst(ast, exportName, function (map) {
    exportBindingAssignments.forEach(function (p) {
      return deep(ast, p, map(deep(ast, p)));
    });
  });
}
var helperData = Object.create(null);
function loadHelper(name) {
  if (!helperData[name]) {
    var helper = _helpersGenerated["default"][name];
    if (!helper) {
      throw Object.assign(new ReferenceError("Unknown helper ".concat(name)), {
        code: "BABEL_HELPER_UNKNOWN",
        helper: name
      });
    }
    helperData[name] = {
      minVersion: helper.minVersion,
      build: function build(getDependency, bindingName, localBindings, adjustAst) {
        var ast = helper.ast();
        permuteHelperAST(ast, helper.metadata, bindingName, localBindings, getDependency, adjustAst);
        return {
          nodes: ast.body,
          globals: helper.metadata.globals
        };
      },
      getDependencies: function getDependencies() {
        return Object.keys(helper.metadata.dependencies);
      }
    };
  }
  return helperData[name];
}
function get(name, getDependency, bindingName, localBindings, adjustAst) {
  {
    if (_typeof(bindingName) === "object") {
      var id = bindingName;
      if ((id == null ? void 0 : id.type) === "Identifier") {
        bindingName = id.name;
      } else {
        bindingName = undefined;
      }
    }
  }
  return loadHelper(name).build(getDependency, bindingName, localBindings, adjustAst);
}
function minVersion(name) {
  return loadHelper(name).minVersion;
}
function getDependencies(name) {
  return loadHelper(name).getDependencies();
}
{
  exports.ensure = function (name) {
    loadHelper(name);
  };
}
var list = exports.list = Object.keys(_helpersGenerated["default"]).map(function (name) {
  return name.replace(/^_/, "");
});
var _default = exports["default"] = get;