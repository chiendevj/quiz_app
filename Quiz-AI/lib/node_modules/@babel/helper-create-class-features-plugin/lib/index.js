"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function get() {
    return _features.FEATURES;
  }
});
Object.defineProperty(exports, "buildCheckInRHS", {
  enumerable: true,
  get: function get() {
    return _fields.buildCheckInRHS;
  }
});
exports.createClassFeaturePlugin = createClassFeaturePlugin;
Object.defineProperty(exports, "enableFeature", {
  enumerable: true,
  get: function get() {
    return _features.enableFeature;
  }
});
Object.defineProperty(exports, "injectInitialization", {
  enumerable: true,
  get: function get() {
    return _misc.injectInitialization;
  }
});
var _core = require("@babel/core");
var _helperFunctionName = require("@babel/helper-function-name");
var _helperSplitExportDeclaration = require("@babel/helper-split-export-declaration");
var _decorators = require("./decorators.js");
var _semver = require("semver");
var _fields = require("./fields.js");
var _decorators2 = require("./decorators-2018-09.js");
var _misc = require("./misc.js");
var _features = require("./features.js");
var _typescript = require("./typescript.js");
var versionKey = "@babel/plugin-class-features/version";
function createClassFeaturePlugin(_ref2) {
  var name = _ref2.name,
    feature = _ref2.feature,
    loose = _ref2.loose,
    manipulateOptions = _ref2.manipulateOptions,
    api = _ref2.api,
    inherits = _ref2.inherits,
    decoratorVersion = _ref2.decoratorVersion;
  var _api$assumption;
  if (feature & _features.FEATURES.decorators) {
    {
      if (decoratorVersion === "2023-11" || decoratorVersion === "2023-05" || decoratorVersion === "2023-01" || decoratorVersion === "2022-03" || decoratorVersion === "2021-12") {
        return (0, _decorators["default"])(api, {
          loose: loose
        }, decoratorVersion, inherits);
      }
    }
  }
  {
    var _api;
    (_api = api) != null ? _api : api = {
      assumption: function assumption() {
        return void 0;
      }
    };
  }
  var setPublicClassFields = api.assumption("setPublicClassFields");
  var privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols");
  var privateFieldsAsProperties = api.assumption("privateFieldsAsProperties");
  var noUninitializedPrivateFieldAccess = (_api$assumption = api.assumption("noUninitializedPrivateFieldAccess")) != null ? _api$assumption : false;
  var constantSuper = api.assumption("constantSuper");
  var noDocumentAll = api.assumption("noDocumentAll");
  if (privateFieldsAsProperties && privateFieldsAsSymbols) {
    throw new Error("Cannot enable both the \"privateFieldsAsProperties\" and " + "\"privateFieldsAsSymbols\" assumptions as the same time.");
  }
  var privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;
  if (loose === true) {
    var explicit = [];
    if (setPublicClassFields !== undefined) {
      explicit.push("\"setPublicClassFields\"");
    }
    if (privateFieldsAsProperties !== undefined) {
      explicit.push("\"privateFieldsAsProperties\"");
    }
    if (privateFieldsAsSymbols !== undefined) {
      explicit.push("\"privateFieldsAsSymbols\"");
    }
    if (explicit.length !== 0) {
      console.warn("[".concat(name, "]: You are using the \"loose: true\" option and you are") + " explicitly setting a value for the ".concat(explicit.join(" and ")) + " assumption".concat(explicit.length > 1 ? "s" : "", ". The \"loose\" option") + " can cause incompatibilities with the other class features" + " plugins, so it's recommended that you replace it with the" + " following top-level option:\n" + "\t\"assumptions\": {\n" + "\t\t\"setPublicClassFields\": true,\n" + "\t\t\"privateFieldsAsSymbols\": true\n" + "\t}");
    }
  }
  return {
    name: name,
    manipulateOptions: manipulateOptions,
    inherits: inherits,
    pre: function pre(file) {
      (0, _features.enableFeature)(file, feature, loose);
      {
        if (typeof file.get(versionKey) === "number") {
          file.set(versionKey, "7.24.6");
          return;
        }
      }
      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), "7.24.6")) {
        file.set(versionKey, "7.24.6");
      }
    },
    visitor: {
      Class: function Class(path, _ref3) {
        var file = _ref3.file;
        var _ref;
        if (file.get(versionKey) !== "7.24.6") return;
        if (!(0, _features.shouldTransform)(path, file)) return;
        var pathIsClassDeclaration = path.isClassDeclaration();
        if (pathIsClassDeclaration) (0, _typescript.assertFieldTransformed)(path);
        var loose = (0, _features.isLoose)(file, feature);
        var constructor;
        var isDecorated = (0, _decorators2.hasDecorators)(path.node);
        var props = [];
        var elements = [];
        var computedPaths = [];
        var privateNames = new Set();
        var body = path.get("body");
        var _iterator = _createForOfIteratorHelper(body.get("body")),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _path = _step.value;
            if ((_path.isClassProperty() || _path.isClassMethod()) && _path.node.computed) {
              computedPaths.push(_path);
            }
            if (_path.isPrivate()) {
              var _name = _path.node.key.id.name;
              var getName = "get ".concat(_name);
              var setName = "set ".concat(_name);
              if (_path.isClassPrivateMethod()) {
                if (_path.node.kind === "get") {
                  if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }
                  privateNames.add(getName).add(_name);
                } else if (_path.node.kind === "set") {
                  if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
                    throw _path.buildCodeFrameError("Duplicate private field");
                  }
                  privateNames.add(setName).add(_name);
                }
              } else {
                if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }
                privateNames.add(_name);
              }
            }
            if (_path.isClassMethod({
              kind: "constructor"
            })) {
              constructor = _path;
            } else {
              elements.push(_path);
              if (_path.isProperty() || _path.isPrivate() || _path.isStaticBlock != null && _path.isStaticBlock()) {
                props.push(_path);
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        {
          if (!props.length && !isDecorated) return;
        }
        var innerBinding = path.node.id;
        var ref;
        if (!innerBinding || !pathIsClassDeclaration) {
          (0, _helperFunctionName["default"])(path);
          ref = path.scope.generateUidIdentifier((innerBinding == null ? void 0 : innerBinding.name) || "Class");
        }
        var classRefForDefine = (_ref = ref) != null ? _ref : _core.types.cloneNode(innerBinding);
        var privateNamesMap = (0, _fields.buildPrivateNamesMap)(classRefForDefine.name, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose, props, file);
        var privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, privateFieldsAsSymbols != null ? privateFieldsAsSymbols : false, file);
        (0, _fields.transformPrivateNamesUsage)(classRefForDefine, path, privateNamesMap, {
          privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose,
          noUninitializedPrivateFieldAccess: noUninitializedPrivateFieldAccess,
          noDocumentAll: noDocumentAll,
          innerBinding: innerBinding
        }, file);
        var keysNodes, staticNodes, instanceNodes, lastInstanceNodeReturnsThis, pureStaticNodes, classBindingNode, wrapClass;
        {
          if (isDecorated) {
            staticNodes = pureStaticNodes = keysNodes = [];
            var _ref4 = (0, _decorators2.buildDecoratedClass)(classRefForDefine, path, elements, file);
            instanceNodes = _ref4.instanceNodes;
            wrapClass = _ref4.wrapClass;
          } else {
            keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file);
            var _ref5 = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose, noUninitializedPrivateFieldAccess, constantSuper != null ? constantSuper : loose, innerBinding);
            staticNodes = _ref5.staticNodes;
            pureStaticNodes = _ref5.pureStaticNodes;
            instanceNodes = _ref5.instanceNodes;
            lastInstanceNodeReturnsThis = _ref5.lastInstanceNodeReturnsThis;
            classBindingNode = _ref5.classBindingNode;
            wrapClass = _ref5.wrapClass;
          }
        }
        if (instanceNodes.length > 0) {
          (0, _misc.injectInitialization)(path, constructor, instanceNodes, function (referenceVisitor, state) {
            {
              if (isDecorated) return;
            }
            var _iterator2 = _createForOfIteratorHelper(props),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var prop = _step2.value;
                if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node["static"]) continue;
                prop.traverse(referenceVisitor, state);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }, lastInstanceNodeReturnsThis);
        }
        var wrappedPath = wrapClass(path);
        wrappedPath.insertBefore([].concat(_toConsumableArray(privateNamesNodes), _toConsumableArray(keysNodes)));
        if (staticNodes.length > 0) {
          wrappedPath.insertAfter(staticNodes);
        }
        if (pureStaticNodes.length > 0) {
          wrappedPath.find(function (parent) {
            return parent.isStatement() || parent.isDeclaration();
          }).insertAfter(pureStaticNodes);
        }
        if (classBindingNode != null && pathIsClassDeclaration) {
          wrappedPath.insertAfter(classBindingNode);
        }
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path, _ref6) {
        var file = _ref6.file;
        {
          if (file.get(versionKey) !== "7.24.6") return;
          var decl = path.get("declaration");
          if (decl.isClassDeclaration() && (0, _decorators2.hasDecorators)(decl.node)) {
            if (decl.node.id) {
              (0, _helperSplitExportDeclaration["default"])(path);
            } else {
              decl.node.type = "ClassExpression";
            }
          }
        }
      }
    }
  };
}