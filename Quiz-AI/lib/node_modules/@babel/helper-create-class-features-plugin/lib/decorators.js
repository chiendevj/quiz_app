"use strict";

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
var _core = require("@babel/core");
var _helperReplaceSupers = require("@babel/helper-replace-supers");
var _helperSplitExportDeclaration = require("@babel/helper-split-export-declaration");
var _helperSkipTransparentExpressionWrappers = require("@babel/helper-skip-transparent-expression-wrappers");
var _fields = require("./fields.js");
var _misc = require("./misc.js");
function incrementId(id) {
  var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id.length - 1;
  if (idx === -1) {
    id.unshift(65);
    return;
  }
  var current = id[idx];
  if (current === 90) {
    id[idx] = 97;
  } else if (current === 122) {
    id[idx] = 65;
    incrementId(id, idx - 1);
  } else {
    id[idx] = current + 1;
  }
}
function createPrivateUidGeneratorForClass(classPath) {
  var currentPrivateId = [];
  var privateNames = new Set();
  classPath.traverse({
    PrivateName: function PrivateName(path) {
      privateNames.add(path.node.id.name);
    }
  });
  return function () {
    var reifiedId;
    do {
      incrementId(currentPrivateId);
      reifiedId = String.fromCharCode.apply(String, currentPrivateId);
    } while (privateNames.has(reifiedId));
    return _core.types.privateName(_core.types.identifier(reifiedId));
  };
}
function createLazyPrivateUidGeneratorForClass(classPath) {
  var generator;
  return function () {
    if (!generator) {
      generator = createPrivateUidGeneratorForClass(classPath);
    }
    return generator();
  };
}
function replaceClassWithVar(path, className) {
  var id = path.node.id;
  var scope = path.scope;
  if (path.type === "ClassDeclaration") {
    var _className2 = id.name;
    var varId = scope.generateUidIdentifierBasedOnNode(id);
    var classId = _core.types.identifier(_className2);
    scope.rename(_className2, varId.name);
    path.get("id").replaceWith(classId);
    return {
      id: _core.types.cloneNode(varId),
      path: path
    };
  } else {
    var _varId;
    if (id) {
      className = id.name;
      _varId = generateLetUidIdentifier(scope.parent, className);
      scope.rename(className, _varId.name);
    } else {
      _varId = generateLetUidIdentifier(scope.parent, typeof className === "string" ? className : "decorated_class");
    }
    var newClassExpr = _core.types.classExpression(typeof className === "string" ? _core.types.identifier(className) : null, path.node.superClass, path.node.body);
    var _path$replaceWith = path.replaceWith(_core.types.sequenceExpression([newClassExpr, _varId])),
      _path$replaceWith2 = _slicedToArray(_path$replaceWith, 1),
      newPath = _path$replaceWith2[0];
    return {
      id: _core.types.cloneNode(_varId),
      path: newPath.get("expressions.0")
    };
  }
}
function generateClassProperty(key, value, isStatic) {
  if (key.type === "PrivateName") {
    return _core.types.classPrivateProperty(key, value, undefined, isStatic);
  } else {
    return _core.types.classProperty(key, value, undefined, undefined, isStatic);
  }
}
function assignIdForAnonymousClass(path, className) {
  if (!path.node.id) {
    path.node.id = typeof className === "string" ? _core.types.identifier(className) : path.scope.generateUidIdentifier("Class");
  }
}
function addProxyAccessorsFor(className, element, getterKey, setterKey, targetKey, isComputed, isStatic, version) {
  var thisArg = (version === "2023-11" || version === "2023-05") && isStatic ? className : _core.types.thisExpression();
  var getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)))]);
  var setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)), _core.types.identifier("v")))]);
  var getter, setter;
  if (getterKey.type === "PrivateName") {
    getter = _core.types.classPrivateMethod("get", getterKey, [], getterBody, isStatic);
    setter = _core.types.classPrivateMethod("set", setterKey, [_core.types.identifier("v")], setterBody, isStatic);
  } else {
    getter = _core.types.classMethod("get", getterKey, [], getterBody, isComputed, isStatic);
    setter = _core.types.classMethod("set", setterKey, [_core.types.identifier("v")], setterBody, isComputed, isStatic);
  }
  element.insertAfter(setter);
  element.insertAfter(getter);
}
function extractProxyAccessorsFor(targetKey, version) {
  if (version !== "2023-11" && version !== "2023-05" && version !== "2023-01") {
    return [_core.template.expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n        function () {\n          return this.", ";\n        }\n      "])), _core.types.cloneNode(targetKey)), _core.template.expression.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        function (value) {\n          this.", " = value;\n        }\n      "])), _core.types.cloneNode(targetKey))];
  }
  return [_core.template.expression.ast(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n      o => o.", "\n    "])), _core.types.cloneNode(targetKey)), _core.template.expression.ast(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n      (o, v) => o.", " = v\n    "])), _core.types.cloneNode(targetKey))];
}
function getComputedKeyLastElement(path) {
  path = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path);
  if (path.isSequenceExpression()) {
    var expressions = path.get("expressions");
    return getComputedKeyLastElement(expressions[expressions.length - 1]);
  }
  return path;
}
function getComputedKeyMemoiser(path) {
  var element = getComputedKeyLastElement(path);
  if (element.isConstantExpression()) {
    return _core.types.cloneNode(path.node);
  } else if (element.isIdentifier() && path.scope.hasUid(element.node.name)) {
    return _core.types.cloneNode(path.node);
  } else if (element.isAssignmentExpression() && element.get("left").isIdentifier()) {
    return _core.types.cloneNode(element.node.left);
  } else {
    throw new Error("Internal Error: the computed key ".concat(path.toString(), " has not yet been memoised."));
  }
}
function prependExpressionsToComputedKey(expressions, fieldPath) {
  var key = fieldPath.get("key");
  if (key.isSequenceExpression()) {
    expressions.push.apply(expressions, _toConsumableArray(key.node.expressions));
  } else {
    expressions.push(key.node);
  }
  key.replaceWith(maybeSequenceExpression(expressions));
}
function appendExpressionsToComputedKey(expressions, fieldPath) {
  var key = fieldPath.get("key");
  var completion = getComputedKeyLastElement(key);
  if (completion.isConstantExpression()) {
    prependExpressionsToComputedKey(expressions, fieldPath);
  } else {
    var scopeParent = key.scope.parent;
    var maybeAssignment = (0, _misc.memoiseComputedKey)(completion.node, scopeParent, scopeParent.generateUid("computedKey"));
    if (!maybeAssignment) {
      prependExpressionsToComputedKey(expressions, fieldPath);
    } else {
      var expressionSequence = [].concat(_toConsumableArray(expressions), [_core.types.cloneNode(maybeAssignment.left)]);
      var completionParent = completion.parentPath;
      if (completionParent.isSequenceExpression()) {
        completionParent.pushContainer("expressions", expressionSequence);
      } else {
        completion.replaceWith(maybeSequenceExpression([_core.types.cloneNode(maybeAssignment)].concat(_toConsumableArray(expressionSequence))));
      }
    }
  }
}
function prependExpressionsToFieldInitializer(expressions, fieldPath) {
  var initializer = fieldPath.get("value");
  if (initializer.node) {
    expressions.push(initializer.node);
  } else if (expressions.length > 0) {
    expressions[expressions.length - 1] = _core.types.unaryExpression("void", expressions[expressions.length - 1]);
  }
  initializer.replaceWith(maybeSequenceExpression(expressions));
}
function prependExpressionsToStaticBlock(expressions, blockPath) {
  blockPath.unshiftContainer("body", _core.types.expressionStatement(maybeSequenceExpression(expressions)));
}
function prependExpressionsToConstructor(expressions, constructorPath) {
  constructorPath.node.body.body.unshift(_core.types.expressionStatement(maybeSequenceExpression(expressions)));
}
function isProtoInitCallExpression(expression, protoInitCall) {
  return _core.types.isCallExpression(expression) && _core.types.isIdentifier(expression.callee, {
    name: protoInitCall.name
  });
}
function optimizeSuperCallAndExpressions(expressions, protoInitLocal) {
  if (protoInitLocal) {
    if (expressions.length >= 2 && isProtoInitCallExpression(expressions[1], protoInitLocal)) {
      var mergedSuperCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [expressions[0]]);
      expressions.splice(0, 2, mergedSuperCall);
    }
    if (expressions.length >= 2 && _core.types.isThisExpression(expressions[expressions.length - 1]) && isProtoInitCallExpression(expressions[expressions.length - 2], protoInitLocal)) {
      expressions.splice(expressions.length - 1, 1);
    }
  }
  return maybeSequenceExpression(expressions);
}
function insertExpressionsAfterSuperCallAndOptimize(expressions, constructorPath, protoInitLocal) {
  constructorPath.traverse({
    CallExpression: {
      exit: function exit(path) {
        if (!path.get("callee").isSuper()) return;
        var newNodes = [path.node].concat(_toConsumableArray(expressions.map(function (expr) {
          return _core.types.cloneNode(expr);
        })));
        if (path.isCompletionRecord()) {
          newNodes.push(_core.types.thisExpression());
        }
        path.replaceWith(optimizeSuperCallAndExpressions(newNodes, protoInitLocal));
        path.skip();
      }
    },
    ClassMethod: function ClassMethod(path) {
      if (path.node.kind === "constructor") {
        path.skip();
      }
    }
  });
}
function createConstructorFromExpressions(expressions, isDerivedClass) {
  var body = [_core.types.expressionStatement(maybeSequenceExpression(expressions))];
  if (isDerivedClass) {
    body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types["super"](), [_core.types.spreadElement(_core.types.identifier("args"))])));
  }
  return _core.types.classMethod("constructor", _core.types.identifier("constructor"), isDerivedClass ? [_core.types.restElement(_core.types.identifier("args"))] : [], _core.types.blockStatement(body));
}
function createStaticBlockFromExpressions(expressions) {
  return _core.types.staticBlock([_core.types.expressionStatement(maybeSequenceExpression(expressions))]);
}
var FIELD = 0;
var ACCESSOR = 1;
var METHOD = 2;
var GETTER = 3;
var SETTER = 4;
var STATIC_OLD_VERSION = 5;
var STATIC = 8;
var DECORATORS_HAVE_THIS = 16;
function getElementKind(element) {
  switch (element.node.type) {
    case "ClassProperty":
    case "ClassPrivateProperty":
      return FIELD;
    case "ClassAccessorProperty":
      return ACCESSOR;
    case "ClassMethod":
    case "ClassPrivateMethod":
      if (element.node.kind === "get") {
        return GETTER;
      } else if (element.node.kind === "set") {
        return SETTER;
      } else {
        return METHOD;
      }
  }
}
function toSortedDecoratorInfo(info) {
  return [].concat(_toConsumableArray(info.filter(function (el) {
    return el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER;
  })), _toConsumableArray(info.filter(function (el) {
    return !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER;
  })), _toConsumableArray(info.filter(function (el) {
    return el.isStatic && el.kind === FIELD;
  })), _toConsumableArray(info.filter(function (el) {
    return !el.isStatic && el.kind === FIELD;
  })));
}
function generateDecorationList(decorators, decoratorsThis, version) {
  var decsCount = decorators.length;
  var haveOneThis = decoratorsThis.some(Boolean);
  var decs = [];
  for (var i = 0; i < decsCount; i++) {
    if ((version === "2023-11" || version === "2023-05") && haveOneThis) {
      decs.push(decoratorsThis[i] || _core.types.unaryExpression("void", _core.types.numericLiteral(0)));
    }
    decs.push(decorators[i].expression);
  }
  return {
    haveThis: haveOneThis,
    decs: decs
  };
}
function generateDecorationExprs(decorationInfo, version) {
  return _core.types.arrayExpression(decorationInfo.map(function (el) {
    var flag = el.kind;
    if (el.isStatic) {
      flag += version === "2023-11" || version === "2023-05" ? STATIC : STATIC_OLD_VERSION;
    }
    if (el.decoratorsHaveThis) flag += DECORATORS_HAVE_THIS;
    return _core.types.arrayExpression([el.decoratorsArray, _core.types.numericLiteral(flag), el.name].concat(_toConsumableArray(el.privateMethods || [])));
  }));
}
function extractElementLocalAssignments(decorationInfo) {
  var localIds = [];
  var _iterator = _createForOfIteratorHelper(decorationInfo),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var el = _step.value;
      var locals = el.locals;
      if (Array.isArray(locals)) {
        localIds.push.apply(localIds, _toConsumableArray(locals));
      } else if (locals !== undefined) {
        localIds.push(locals);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return localIds;
}
function addCallAccessorsFor(version, element, key, getId, setId, isStatic) {
  element.insertAfter(_core.types.classPrivateMethod("get", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()]))]), isStatic));
  element.insertAfter(_core.types.classPrivateMethod("set", _core.types.cloneNode(key), [_core.types.identifier("v")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), version === "2023-11" && isStatic ? [_core.types.identifier("v")] : [_core.types.thisExpression(), _core.types.identifier("v")]))]), isStatic));
}
function movePrivateAccessor(element, key, methodLocalVar, isStatic) {
  var params;
  var block;
  if (element.node.kind === "set") {
    params = [_core.types.identifier("v")];
    block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier("v")]))];
  } else {
    params = [];
    block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))];
  }
  element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));
}
function isClassDecoratableElementPath(path) {
  var type = path.type;
  return type !== "TSDeclareMethod" && type !== "TSIndexSignature" && type !== "StaticBlock";
}
function staticBlockToIIFE(block) {
  return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);
}
function staticBlockToFunctionClosure(block) {
  return _core.types.functionExpression(null, [], _core.types.blockStatement(block.body));
}
function fieldInitializerToClosure(value) {
  return _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(value)]));
}
function maybeSequenceExpression(exprs) {
  if (exprs.length === 0) return _core.types.unaryExpression("void", _core.types.numericLiteral(0));
  if (exprs.length === 1) return exprs[0];
  return _core.types.sequenceExpression(exprs);
}
function createFunctionExpressionFromPrivateMethod(node) {
  var params = node.params,
    body = node.body,
    isGenerator = node.generator,
    isAsync = node.async;
  return _core.types.functionExpression(undefined, params, body, isGenerator, isAsync);
}
function createSetFunctionNameCall(state, className) {
  return _core.types.callExpression(state.addHelper("setFunctionName"), [_core.types.thisExpression(), className]);
}
function createToPropertyKeyCall(state, propertyKey) {
  return _core.types.callExpression(state.addHelper("toPropertyKey"), [propertyKey]);
}
function createPrivateBrandCheckClosure(brandName) {
  return _core.types.arrowFunctionExpression([_core.types.identifier("_")], _core.types.binaryExpression("in", _core.types.cloneNode(brandName), _core.types.identifier("_")));
}
function usesPrivateField(expression) {
  try {
    _core.types.traverseFast(expression, function (node) {
      if (_core.types.isPrivateName(node)) {
        throw null;
      }
    });
    return false;
  } catch (_unused) {
    return true;
  }
}
function convertToComputedKey(path) {
  var node = path.node;
  node.computed = true;
  if (_core.types.isIdentifier(node.key)) {
    node.key = _core.types.stringLiteral(node.key.name);
  }
}
function hasInstancePrivateAccess(path, privateNames) {
  var containsInstancePrivateAccess = false;
  if (privateNames.length > 0) {
    var privateNameVisitor = (0, _fields.privateNameVisitorFactory)({
      PrivateName: function PrivateName(path, state) {
        if (state.privateNamesMap.has(path.node.id.name)) {
          containsInstancePrivateAccess = true;
          path.stop();
        }
      }
    });
    var privateNamesMap = new Map();
    var _iterator2 = _createForOfIteratorHelper(privateNames),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var name = _step2.value;
        privateNamesMap.set(name, null);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    path.traverse(privateNameVisitor, {
      privateNamesMap: privateNamesMap
    });
  }
  return containsInstancePrivateAccess;
}
function checkPrivateMethodUpdateError(path, decoratedPrivateMethods) {
  var privateNameVisitor = (0, _fields.privateNameVisitorFactory)({
    PrivateName: function PrivateName(path, state) {
      if (!state.privateNamesMap.has(path.node.id.name)) return;
      var parentPath = path.parentPath;
      var parentParentPath = parentPath.parentPath;
      if (parentParentPath.node.type === "AssignmentExpression" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === "UpdateExpression" || parentParentPath.node.type === "RestElement" || parentParentPath.node.type === "ArrayPattern" || parentParentPath.node.type === "ObjectProperty" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === "ObjectPattern" || parentParentPath.node.type === "ForOfStatement" && parentParentPath.node.left === parentPath.node) {
        throw path.buildCodeFrameError("Decorated private methods are read-only, but \"#".concat(path.node.id.name, "\" is updated via this expression."));
      }
    }
  });
  var privateNamesMap = new Map();
  var _iterator3 = _createForOfIteratorHelper(decoratedPrivateMethods),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var name = _step3.value;
      privateNamesMap.set(name, null);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  path.traverse(privateNameVisitor, {
    privateNamesMap: privateNamesMap
  });
}
function transformClass(path, state, constantSuper, ignoreFunctionLength, className, propertyVisitor, version) {
  var _path$node$id, _classDecorationsId;
  var body = path.get("body.body");
  var classDecorators = path.node.decorators;
  var hasElementDecorators = false;
  var hasComputedKeysSideEffects = false;
  var elemDecsUseFnContext = false;
  var generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);
  var classAssignments = [];
  var scopeParent = path.scope.parent;
  var memoiseExpression = function memoiseExpression(expression, hint, assignments) {
    var localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);
    assignments.push(_core.types.assignmentExpression("=", localEvaluatedId, expression));
    return _core.types.cloneNode(localEvaluatedId);
  };
  var protoInitLocal;
  var staticInitLocal;
  var classIdName = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;
  var setClassName = _typeof(className) === "object" ? className : undefined;
  var usesFunctionContextOrYieldAwait = function usesFunctionContextOrYieldAwait(decorator) {
    try {
      _core.types.traverseFast(decorator, function (node) {
        if (_core.types.isThisExpression(node) || _core.types.isSuper(node) || _core.types.isYieldExpression(node) || _core.types.isAwaitExpression(node) || _core.types.isIdentifier(node, {
          name: "arguments"
        }) || classIdName && _core.types.isIdentifier(node, {
          name: classIdName
        }) || _core.types.isMetaProperty(node) && node.meta.name !== "import") {
          throw null;
        }
      });
      return false;
    } catch (_unused2) {
      return true;
    }
  };
  var instancePrivateNames = [];
  var _iterator4 = _createForOfIteratorHelper(body),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _element2 = _step4.value;
      if (!isClassDecoratableElementPath(_element2)) {
        continue;
      }
      var elementNode = _element2.node;
      if (!elementNode["static"] && _core.types.isPrivateName(elementNode.key)) {
        instancePrivateNames.push(elementNode.key.id.name);
      }
      if (isDecorated(elementNode)) {
        switch (elementNode.type) {
          case "ClassProperty":
            propertyVisitor.ClassProperty(_element2, state);
            break;
          case "ClassPrivateProperty":
            propertyVisitor.ClassPrivateProperty(_element2, state);
            break;
          case "ClassAccessorProperty":
            propertyVisitor.ClassAccessorProperty(_element2, state);
            if (version === "2023-11") {
              break;
            }
          default:
            if (elementNode["static"]) {
              var _staticInitLocal;
              (_staticInitLocal = staticInitLocal) != null ? _staticInitLocal : staticInitLocal = generateLetUidIdentifier(scopeParent, "initStatic");
            } else {
              var _protoInitLocal;
              (_protoInitLocal = protoInitLocal) != null ? _protoInitLocal : protoInitLocal = generateLetUidIdentifier(scopeParent, "initProto");
            }
            break;
        }
        hasElementDecorators = true;
        elemDecsUseFnContext || (elemDecsUseFnContext = elementNode.decorators.some(usesFunctionContextOrYieldAwait));
      } else if (elementNode.type === "ClassAccessorProperty") {
        propertyVisitor.ClassAccessorProperty(_element2, state);
        var _key3 = elementNode.key,
          _value = elementNode.value,
          _isStatic = elementNode["static"],
          computed = elementNode.computed;
        var _newId = generateClassPrivateUid();
        var _newField = generateClassProperty(_newId, _value, _isStatic);
        var keyPath = _element2.get("key");
        var _element2$replaceWith = _element2.replaceWith(_newField),
          _element2$replaceWith2 = _slicedToArray(_element2$replaceWith, 1),
          _newPath2 = _element2$replaceWith2[0];
        var getterKey = void 0,
          setterKey = void 0;
        if (computed && !keyPath.isConstantExpression()) {
          getterKey = (0, _misc.memoiseComputedKey)(createToPropertyKeyCall(state, _key3), scopeParent, scopeParent.generateUid("computedKey"));
          setterKey = _core.types.cloneNode(getterKey.left);
        } else {
          getterKey = _core.types.cloneNode(_key3);
          setterKey = _core.types.cloneNode(_key3);
        }
        assignIdForAnonymousClass(path, className);
        addProxyAccessorsFor(path.node.id, _newPath2, getterKey, setterKey, _newId, computed, _isStatic, version);
      }
      if ("computed" in _element2.node && _element2.node.computed) {
        hasComputedKeysSideEffects || (hasComputedKeysSideEffects = !scopeParent.isStatic(_element2.node.key));
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  if (!classDecorators && !hasElementDecorators) {
    if (!path.node.id && typeof className === "string") {
      path.node.id = _core.types.identifier(className);
    }
    if (setClassName) {
      path.node.body.body.unshift(createStaticBlockFromExpressions([createSetFunctionNameCall(state, setClassName)]));
    }
    return;
  }
  var elementDecoratorInfo = [];
  var constructorPath;
  var decoratedPrivateMethods = new Set();
  var classInitLocal, classIdLocal;
  var decoratorReceiverId = null;
  function handleDecorators(decorators) {
    var hasSideEffects = false;
    var usesFnContext = false;
    var decoratorsThis = [];
    var _iterator5 = _createForOfIteratorHelper(decorators),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var decorator = _step5.value;
        var expression = decorator.expression;
        var object = void 0;
        if ((version === "2023-11" || version === "2023-05") && _core.types.isMemberExpression(expression)) {
          if (_core.types.isSuper(expression.object)) {
            object = _core.types.thisExpression();
          } else if (scopeParent.isStatic(expression.object)) {
            object = _core.types.cloneNode(expression.object);
          } else {
            var _decoratorReceiverId;
            (_decoratorReceiverId = decoratorReceiverId) != null ? _decoratorReceiverId : decoratorReceiverId = generateLetUidIdentifier(scopeParent, "obj");
            object = _core.types.assignmentExpression("=", _core.types.cloneNode(decoratorReceiverId), expression.object);
            expression.object = _core.types.cloneNode(decoratorReceiverId);
          }
        }
        decoratorsThis.push(object);
        hasSideEffects || (hasSideEffects = !scopeParent.isStatic(expression));
        usesFnContext || (usesFnContext = usesFunctionContextOrYieldAwait(decorator));
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    return {
      hasSideEffects: hasSideEffects,
      usesFnContext: usesFnContext,
      decoratorsThis: decoratorsThis
    };
  }
  var willExtractSomeElemDecs = hasComputedKeysSideEffects || elemDecsUseFnContext || version !== "2023-11";
  var needsDeclaraionForClassBinding = false;
  var classDecorationsFlag = 0;
  var classDecorations = [];
  var classDecorationsId;
  var computedKeyAssignments = [];
  if (classDecorators) {
    classInitLocal = generateLetUidIdentifier(scopeParent, "initClass");
    needsDeclaraionForClassBinding = path.isClassDeclaration();
    var _replaceClassWithVar = replaceClassWithVar(path, className);
    classIdLocal = _replaceClassWithVar.id;
    path = _replaceClassWithVar.path;
    path.node.decorators = null;
    var classDecsUsePrivateName = classDecorators.some(usesPrivateField);
    var _handleDecorators = handleDecorators(classDecorators),
      hasSideEffects = _handleDecorators.hasSideEffects,
      usesFnContext = _handleDecorators.usesFnContext,
      decoratorsThis = _handleDecorators.decoratorsThis;
    var _generateDecorationLi = generateDecorationList(classDecorators, decoratorsThis, version),
      haveThis = _generateDecorationLi.haveThis,
      decs = _generateDecorationLi.decs;
    classDecorationsFlag = haveThis ? 1 : 0;
    classDecorations = decs;
    if (usesFnContext || hasSideEffects && willExtractSomeElemDecs || classDecsUsePrivateName) {
      classDecorationsId = memoiseExpression(_core.types.arrayExpression(classDecorations), "classDecs", classAssignments);
    }
    if (!hasElementDecorators) {
      var _iterator6 = _createForOfIteratorHelper(path.get("body.body")),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var element = _step6.value;
          var node = element.node;
          var isComputed = "computed" in node && node.computed;
          if (isComputed) {
            if (element.isClassProperty({
              "static": true
            })) {
              if (!element.get("key").isConstantExpression()) {
                var key = node.key;
                var maybeAssignment = (0, _misc.memoiseComputedKey)(key, scopeParent, scopeParent.generateUid("computedKey"));
                if (maybeAssignment != null) {
                  node.key = _core.types.cloneNode(maybeAssignment.left);
                  computedKeyAssignments.push(maybeAssignment);
                }
              }
            } else if (computedKeyAssignments.length > 0) {
              prependExpressionsToComputedKey(computedKeyAssignments, element);
              computedKeyAssignments = [];
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  } else {
    assignIdForAnonymousClass(path, className);
    classIdLocal = _core.types.cloneNode(path.node.id);
  }
  var lastInstancePrivateName;
  var needsInstancePrivateBrandCheck = false;
  var fieldInitializerExpressions = [];
  var staticFieldInitializerExpressions = [];
  if (hasElementDecorators) {
    if (protoInitLocal) {
      var protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);
      fieldInitializerExpressions.push(protoInitCall);
    }
    var _iterator7 = _createForOfIteratorHelper(body),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _element = _step7.value;
        if (!isClassDecoratableElementPath(_element)) {
          if (staticFieldInitializerExpressions.length > 0 && _element.isStaticBlock()) {
            prependExpressionsToStaticBlock(staticFieldInitializerExpressions, _element);
            staticFieldInitializerExpressions = [];
          }
          continue;
        }
        var _node = _element.node;
        var decorators = _node.decorators;
        var hasDecorators = !!(decorators != null && decorators.length);
        var _isComputed = "computed" in _node && _node.computed;
        var name = "computedKey";
        if (_node.key.type === "PrivateName") {
          name = _node.key.id.name;
        } else if (!_isComputed && _node.key.type === "Identifier") {
          name = _node.key.name;
        }
        var decoratorsArray = void 0;
        var decoratorsHaveThis = void 0;
        if (hasDecorators) {
          var _handleDecorators2 = handleDecorators(decorators),
            _hasSideEffects = _handleDecorators2.hasSideEffects,
            _usesFnContext = _handleDecorators2.usesFnContext,
            _decoratorsThis = _handleDecorators2.decoratorsThis;
          var _generateDecorationLi2 = generateDecorationList(decorators, _decoratorsThis, version),
            _decs = _generateDecorationLi2.decs,
            _haveThis = _generateDecorationLi2.haveThis;
          decoratorsHaveThis = _haveThis;
          decoratorsArray = _decs.length === 1 ? _decs[0] : _core.types.arrayExpression(_decs);
          if (_usesFnContext || _hasSideEffects && willExtractSomeElemDecs) {
            decoratorsArray = memoiseExpression(decoratorsArray, name + "Decs", computedKeyAssignments);
          }
        }
        if (_isComputed) {
          if (!_element.get("key").isConstantExpression()) {
            var _key = _node.key;
            var _maybeAssignment = (0, _misc.memoiseComputedKey)(hasDecorators ? createToPropertyKeyCall(state, _key) : _key, scopeParent, scopeParent.generateUid("computedKey"));
            if (_maybeAssignment != null) {
              if (classDecorators && _element.isClassProperty({
                "static": true
              })) {
                _node.key = _core.types.cloneNode(_maybeAssignment.left);
                computedKeyAssignments.push(_maybeAssignment);
              } else {
                _node.key = _maybeAssignment;
              }
            }
          }
        }
        var _key2 = _node.key,
          isStatic = _node["static"];
        var isPrivate = _key2.type === "PrivateName";
        var kind = getElementKind(_element);
        if (isPrivate && !isStatic) {
          if (hasDecorators) {
            needsInstancePrivateBrandCheck = true;
          }
          if (_core.types.isClassPrivateProperty(_node) || !lastInstancePrivateName) {
            lastInstancePrivateName = _key2;
          }
        }
        if (_element.isClassMethod({
          kind: "constructor"
        })) {
          constructorPath = _element;
        }
        var locals = void 0;
        if (hasDecorators) {
          var privateMethods = void 0;
          var nameExpr = void 0;
          if (_isComputed) {
            nameExpr = getComputedKeyMemoiser(_element.get("key"));
          } else if (_key2.type === "PrivateName") {
            nameExpr = _core.types.stringLiteral(_key2.id.name);
          } else if (_key2.type === "Identifier") {
            nameExpr = _core.types.stringLiteral(_key2.name);
          } else {
            nameExpr = _core.types.cloneNode(_key2);
          }
          if (kind === ACCESSOR) {
            var value = _element.node.value;
            var params = version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()];
            if (value) {
              params.push(_core.types.cloneNode(value));
            }
            var newId = generateClassPrivateUid();
            var newFieldInitId = generateLetUidIdentifier(scopeParent, "init_".concat(name));
            var newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params);
            var newField = generateClassProperty(newId, newValue, isStatic);
            var _element$replaceWith = _element.replaceWith(newField),
              _element$replaceWith2 = _slicedToArray(_element$replaceWith, 1),
              newPath = _element$replaceWith2[0];
            if (isPrivate) {
              privateMethods = extractProxyAccessorsFor(newId, version);
              var getId = generateLetUidIdentifier(scopeParent, "get_".concat(name));
              var setId = generateLetUidIdentifier(scopeParent, "set_".concat(name));
              addCallAccessorsFor(version, newPath, _key2, getId, setId, isStatic);
              locals = [newFieldInitId, getId, setId];
            } else {
              assignIdForAnonymousClass(path, className);
              addProxyAccessorsFor(path.node.id, newPath, _core.types.cloneNode(_key2), _core.types.isAssignmentExpression(_key2) ? _core.types.cloneNode(_key2.left) : _core.types.cloneNode(_key2), newId, _isComputed, isStatic, version);
              locals = [newFieldInitId];
            }
          } else if (kind === FIELD) {
            var initId = generateLetUidIdentifier(scopeParent, "init_".concat(name));
            var valuePath = _element.get("value");
            var args = version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()];
            if (valuePath.node) args.push(valuePath.node);
            valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), args));
            locals = [initId];
            if (isPrivate) {
              privateMethods = extractProxyAccessorsFor(_key2, version);
            }
          } else if (isPrivate) {
            var callId = generateLetUidIdentifier(scopeParent, "call_".concat(name));
            locals = [callId];
            var replaceSupers = new _helperReplaceSupers["default"]({
              constantSuper: constantSuper,
              methodPath: _element,
              objectRef: classIdLocal,
              superRef: path.node.superClass,
              file: state.file,
              refToPreserve: classIdLocal
            });
            replaceSupers.replace();
            privateMethods = [createFunctionExpressionFromPrivateMethod(_element.node)];
            if (kind === GETTER || kind === SETTER) {
              movePrivateAccessor(_element, _core.types.cloneNode(_key2), _core.types.cloneNode(callId), isStatic);
            } else {
              var _node2 = _element.node;
              path.node.body.body.unshift(_core.types.classPrivateProperty(_key2, _core.types.cloneNode(callId), [], _node2["static"]));
              decoratedPrivateMethods.add(_key2.id.name);
              _element.remove();
            }
          }
          elementDecoratorInfo.push({
            kind: kind,
            decoratorsArray: decoratorsArray,
            decoratorsHaveThis: decoratorsHaveThis,
            name: nameExpr,
            isStatic: isStatic,
            privateMethods: privateMethods,
            locals: locals
          });
          if (_element.node) {
            _element.node.decorators = null;
          }
        }
        if (_isComputed && computedKeyAssignments.length > 0) {
          if (classDecorators && _element.isClassProperty({
            "static": true
          })) {} else {
            prependExpressionsToComputedKey(computedKeyAssignments, kind === ACCESSOR ? _element.getNextSibling() : _element);
            computedKeyAssignments = [];
          }
        }
        if (fieldInitializerExpressions.length > 0 && !isStatic && (kind === FIELD || kind === ACCESSOR)) {
          prependExpressionsToFieldInitializer(fieldInitializerExpressions, _element);
          fieldInitializerExpressions = [];
        }
        if (staticFieldInitializerExpressions.length > 0 && isStatic && (kind === FIELD || kind === ACCESSOR)) {
          prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, _element);
          staticFieldInitializerExpressions = [];
        }
        if (hasDecorators && version === "2023-11") {
          if (kind === FIELD || kind === ACCESSOR) {
            var initExtraId = generateLetUidIdentifier(scopeParent, "init_extra_".concat(name));
            locals.push(initExtraId);
            var initExtraCall = _core.types.callExpression(_core.types.cloneNode(initExtraId), isStatic ? [] : [_core.types.thisExpression()]);
            if (!isStatic) {
              fieldInitializerExpressions.push(initExtraCall);
            } else {
              staticFieldInitializerExpressions.push(initExtraCall);
            }
          }
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  if (computedKeyAssignments.length > 0) {
    var elements = path.get("body.body");
    var lastComputedElement;
    for (var i = elements.length - 1; i >= 0; i--) {
      var _path = elements[i];
      var _node3 = _path.node;
      if (_node3.computed) {
        if (classDecorators && _core.types.isClassProperty(_node3, {
          "static": true
        })) {
          continue;
        }
        lastComputedElement = _path;
        break;
      }
    }
    if (lastComputedElement != null) {
      appendExpressionsToComputedKey(computedKeyAssignments, lastComputedElement);
      computedKeyAssignments = [];
    } else {}
  }
  if (fieldInitializerExpressions.length > 0) {
    var isDerivedClass = !!path.node.superClass;
    if (constructorPath) {
      if (isDerivedClass) {
        insertExpressionsAfterSuperCallAndOptimize(fieldInitializerExpressions, constructorPath, protoInitLocal);
      } else {
        prependExpressionsToConstructor(fieldInitializerExpressions, constructorPath);
      }
    } else {
      path.node.body.body.unshift(createConstructorFromExpressions(fieldInitializerExpressions, isDerivedClass));
    }
    fieldInitializerExpressions = [];
  }
  if (staticFieldInitializerExpressions.length > 0) {
    path.node.body.body.push(createStaticBlockFromExpressions(staticFieldInitializerExpressions));
    staticFieldInitializerExpressions = [];
  }
  var sortedElementDecoratorInfo = toSortedDecoratorInfo(elementDecoratorInfo);
  var elementDecorations = generateDecorationExprs(version === "2023-11" ? elementDecoratorInfo : sortedElementDecoratorInfo, version);
  var elementLocals = extractElementLocalAssignments(sortedElementDecoratorInfo);
  if (protoInitLocal) {
    elementLocals.push(protoInitLocal);
  }
  if (staticInitLocal) {
    elementLocals.push(staticInitLocal);
  }
  var classLocals = [];
  var classInitInjected = false;
  var classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []);
  var originalClassPath = path;
  var originalClass = path.node;
  var staticClosures = [];
  if (classDecorators) {
    classLocals.push(classIdLocal, classInitLocal);
    var statics = [];
    path.get("body.body").forEach(function (element) {
      if (element.isStaticBlock()) {
        if (hasInstancePrivateAccess(element, instancePrivateNames)) {
          var staticBlockClosureId = memoiseExpression(staticBlockToFunctionClosure(element.node), "staticBlock", staticClosures);
          staticFieldInitializerExpressions.push(_core.types.callExpression(_core.types.memberExpression(staticBlockClosureId, _core.types.identifier("call")), [_core.types.thisExpression()]));
        } else {
          staticFieldInitializerExpressions.push(staticBlockToIIFE(element.node));
        }
        element.remove();
        return;
      }
      if ((element.isClassProperty() || element.isClassPrivateProperty()) && element.node["static"]) {
        var _valuePath = element.get("value");
        if (hasInstancePrivateAccess(_valuePath, instancePrivateNames)) {
          var fieldValueClosureId = memoiseExpression(fieldInitializerToClosure(_valuePath.node), "fieldValue", staticClosures);
          _valuePath.replaceWith(_core.types.callExpression(_core.types.memberExpression(fieldValueClosureId, _core.types.identifier("call")), [_core.types.thisExpression()]));
        }
        if (staticFieldInitializerExpressions.length > 0) {
          prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element);
          staticFieldInitializerExpressions = [];
        }
        element.node["static"] = false;
        statics.push(element.node);
        element.remove();
      } else if (element.isClassPrivateMethod({
        "static": true
      })) {
        if (hasInstancePrivateAccess(element, instancePrivateNames)) {
          var _replaceSupers = new _helperReplaceSupers["default"]({
            constantSuper: constantSuper,
            methodPath: element,
            objectRef: classIdLocal,
            superRef: path.node.superClass,
            file: state.file,
            refToPreserve: classIdLocal
          });
          _replaceSupers.replace();
          var privateMethodDelegateId = memoiseExpression(createFunctionExpressionFromPrivateMethod(element.node), element.get("key.id").node.name, staticClosures);
          if (ignoreFunctionLength) {
            element.node.params = [_core.types.restElement(_core.types.identifier("arg"))];
            element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier("apply")), [_core.types.thisExpression(), _core.types.identifier("arg")]))]);
          } else {
            element.node.params = element.node.params.map(function (p, i) {
              if (_core.types.isRestElement(p)) {
                return _core.types.restElement(_core.types.identifier("arg"));
              } else {
                return _core.types.identifier("_" + i);
              }
            });
            element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier("apply")), [_core.types.thisExpression(), _core.types.identifier("arguments")]))]);
          }
        }
        element.node["static"] = false;
        statics.push(element.node);
        element.remove();
      }
    });
    if (statics.length > 0 || staticFieldInitializerExpressions.length > 0) {
      var staticsClass = _core.template.expression.ast(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n        class extends ", " {}\n      "])), state.addHelper("identity"));
      staticsClass.body.body = [_core.types.classProperty(_core.types.toExpression(originalClass), undefined, undefined, undefined, true, true)].concat(statics);
      var constructorBody = [];
      var newExpr = _core.types.newExpression(staticsClass, []);
      if (staticFieldInitializerExpressions.length > 0) {
        constructorBody.push.apply(constructorBody, _toConsumableArray(staticFieldInitializerExpressions));
      }
      if (classInitCall) {
        classInitInjected = true;
        constructorBody.push(classInitCall);
      }
      if (constructorBody.length > 0) {
        constructorBody.unshift(_core.types.callExpression(_core.types["super"](), [_core.types.cloneNode(classIdLocal)]));
        staticsClass.body.body.push(createConstructorFromExpressions(constructorBody, false));
      } else {
        newExpr.arguments.push(_core.types.cloneNode(classIdLocal));
      }
      var _path$replaceWith3 = path.replaceWith(newExpr),
        _path$replaceWith4 = _slicedToArray(_path$replaceWith3, 1),
        _newPath = _path$replaceWith4[0];
      originalClassPath = _newPath.get("callee").get("body").get("body.0.key");
    }
  }
  if (!classInitInjected && classInitCall) {
    path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));
  }
  var superClass = originalClass.superClass;
  if (superClass && (version === "2023-11" || version === "2023-05")) {
    var id = path.scope.maybeGenerateMemoised(superClass);
    if (id) {
      originalClass.superClass = _core.types.assignmentExpression("=", id, superClass);
      superClass = id;
    }
  }
  var applyDecoratorWrapper = _core.types.staticBlock([]);
  originalClass.body.body.unshift(applyDecoratorWrapper);
  var applyDecsBody = applyDecoratorWrapper.body;
  if (computedKeyAssignments.length > 0) {
    var _elements = originalClassPath.get("body.body");
    var firstPublicElement;
    var _iterator8 = _createForOfIteratorHelper(_elements),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _path2 = _step8.value;
        if ((_path2.isClassProperty() || _path2.isClassMethod()) && _path2.node.kind !== "constructor") {
          firstPublicElement = _path2;
          break;
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
    if (firstPublicElement != null) {
      convertToComputedKey(firstPublicElement);
      prependExpressionsToComputedKey(computedKeyAssignments, firstPublicElement);
    } else {
      originalClass.body.body.unshift(_core.types.classProperty(_core.types.sequenceExpression([].concat(_toConsumableArray(computedKeyAssignments), [_core.types.stringLiteral("_")])), undefined, undefined, undefined, true, true));
      applyDecsBody.push(_core.types.expressionStatement(_core.types.unaryExpression("delete", _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("_")))));
    }
    computedKeyAssignments = [];
  }
  applyDecsBody.push(_core.types.expressionStatement(createLocalsAssignment(elementLocals, classLocals, elementDecorations, (_classDecorationsId = classDecorationsId) != null ? _classDecorationsId : _core.types.arrayExpression(classDecorations), _core.types.numericLiteral(classDecorationsFlag), needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, setClassName, _core.types.cloneNode(superClass), state, version)));
  if (staticInitLocal) {
    applyDecsBody.push(_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()])));
  }
  if (staticClosures.length > 0) {
    applyDecsBody.push.apply(applyDecsBody, _toConsumableArray(staticClosures.map(function (expr) {
      return _core.types.expressionStatement(expr);
    })));
  }
  path.insertBefore(classAssignments.map(function (expr) {
    return _core.types.expressionStatement(expr);
  }));
  if (needsDeclaraionForClassBinding) {
    var classBindingInfo = scopeParent.getBinding(classIdLocal.name);
    if (!classBindingInfo.constantViolations.length) {
      path.insertBefore(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]));
    } else {
      var classOuterBindingDelegateLocal = scopeParent.generateUidIdentifier("t" + classIdLocal.name);
      var classOuterBindingLocal = classIdLocal;
      path.replaceWithMultiple([_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classOuterBindingLocal)), _core.types.variableDeclarator(classOuterBindingDelegateLocal)]), _core.types.blockStatement([_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]), path.node, _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classOuterBindingDelegateLocal), _core.types.cloneNode(classIdLocal)))]), _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classOuterBindingLocal), _core.types.cloneNode(classOuterBindingDelegateLocal)))]);
    }
  }
  if (decoratedPrivateMethods.size > 0) {
    checkPrivateMethodUpdateError(path, decoratedPrivateMethods);
  }
  path.scope.crawl();
  return path;
}
function createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorations, classDecorationsFlag, maybePrivateBrandName, setClassName, superClass, state, version) {
  var lhs, rhs;
  var args = [setClassName ? createSetFunctionNameCall(state, setClassName) : _core.types.thisExpression(), classDecorations, elementDecorations];
  {
    if (version !== "2023-11") {
      args.splice(1, 2, elementDecorations, classDecorations);
    }
    if (version === "2021-12" || version === "2022-03" && !state.availableHelper("applyDecs2203R")) {
      lhs = _core.types.arrayPattern([].concat(_toConsumableArray(elementLocals), _toConsumableArray(classLocals)));
      rhs = _core.types.callExpression(state.addHelper(version === "2021-12" ? "applyDecs" : "applyDecs2203"), args);
      return _core.types.assignmentExpression("=", lhs, rhs);
    } else if (version === "2022-03") {
      rhs = _core.types.callExpression(state.addHelper("applyDecs2203R"), args);
    } else if (version === "2023-01") {
      if (maybePrivateBrandName) {
        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));
      }
      rhs = _core.types.callExpression(state.addHelper("applyDecs2301"), args);
    } else if (version === "2023-05") {
      if (maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) {
        args.push(classDecorationsFlag);
      }
      if (maybePrivateBrandName) {
        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));
      } else if (superClass) {
        args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0)));
      }
      if (superClass) args.push(superClass);
      rhs = _core.types.callExpression(state.addHelper("applyDecs2305"), args);
    }
  }
  if (version === "2023-11") {
    if (maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) {
      args.push(classDecorationsFlag);
    }
    if (maybePrivateBrandName) {
      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));
    } else if (superClass) {
      args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0)));
    }
    if (superClass) args.push(superClass);
    rhs = _core.types.callExpression(state.addHelper("applyDecs2311"), args);
  }
  if (elementLocals.length > 0) {
    if (classLocals.length > 0) {
      lhs = _core.types.objectPattern([_core.types.objectProperty(_core.types.identifier("e"), _core.types.arrayPattern(elementLocals)), _core.types.objectProperty(_core.types.identifier("c"), _core.types.arrayPattern(classLocals))]);
    } else {
      lhs = _core.types.arrayPattern(elementLocals);
      rhs = _core.types.memberExpression(rhs, _core.types.identifier("e"), false, false);
    }
  } else {
    lhs = _core.types.arrayPattern(classLocals);
    rhs = _core.types.memberExpression(rhs, _core.types.identifier("c"), false, false);
  }
  return _core.types.assignmentExpression("=", lhs, rhs);
}
function isProtoKey(node) {
  return node.type === "Identifier" ? node.name === "__proto__" : node.value === "__proto__";
}
function isDecorated(node) {
  return node.decorators && node.decorators.length > 0;
}
function shouldTransformElement(node) {
  switch (node.type) {
    case "ClassAccessorProperty":
      return true;
    case "ClassMethod":
    case "ClassProperty":
    case "ClassPrivateMethod":
    case "ClassPrivateProperty":
      return isDecorated(node);
    default:
      return false;
  }
}
function shouldTransformClass(node) {
  return isDecorated(node) || node.body.body.some(shouldTransformElement);
}
function NamedEvaluationVisitoryFactory(isAnonymous, visitor) {
  function handleComputedProperty(propertyPath, key, state) {
    switch (key.type) {
      case "StringLiteral":
        return _core.types.stringLiteral(key.value);
      case "NumericLiteral":
      case "BigIntLiteral":
        {
          var keyValue = key.value + "";
          propertyPath.get("key").replaceWith(_core.types.stringLiteral(keyValue));
          return _core.types.stringLiteral(keyValue);
        }
      default:
        {
          var ref = propertyPath.scope.maybeGenerateMemoised(key);
          propertyPath.get("key").replaceWith(_core.types.assignmentExpression("=", ref, createToPropertyKeyCall(state, key)));
          return _core.types.cloneNode(ref);
        }
    }
  }
  return {
    VariableDeclarator: function VariableDeclarator(path, state) {
      var id = path.node.id;
      if (id.type === "Identifier") {
        var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("init"));
        if (isAnonymous(initializer)) {
          var name = id.name;
          visitor(initializer, state, name);
        }
      }
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      var id = path.node.left;
      if (id.type === "Identifier") {
        var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));
        if (isAnonymous(initializer)) {
          switch (path.node.operator) {
            case "=":
            case "&&=":
            case "||=":
            case "??=":
              visitor(initializer, state, id.name);
          }
        }
      }
    },
    AssignmentPattern: function AssignmentPattern(path, state) {
      var id = path.node.left;
      if (id.type === "Identifier") {
        var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));
        if (isAnonymous(initializer)) {
          var name = id.name;
          visitor(initializer, state, name);
        }
      }
    },
    ObjectExpression: function ObjectExpression(path, state) {
      var _iterator9 = _createForOfIteratorHelper(path.get("properties")),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var propertyPath = _step9.value;
          if (!propertyPath.isObjectProperty()) continue;
          var node = propertyPath.node;
          var id = node.key;
          var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(propertyPath.get("value"));
          if (isAnonymous(initializer)) {
            if (!node.computed) {
              if (!isProtoKey(id)) {
                if (id.type === "Identifier") {
                  visitor(initializer, state, id.name);
                } else {
                  var className = _core.types.stringLiteral(id.value + "");
                  visitor(initializer, state, className);
                }
              }
            } else {
              var ref = handleComputedProperty(propertyPath, id, state);
              visitor(initializer, state, ref);
            }
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
    },
    ClassPrivateProperty: function ClassPrivateProperty(path, state) {
      var node = path.node;
      var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
      if (isAnonymous(initializer)) {
        var className = _core.types.stringLiteral("#" + node.key.id.name);
        visitor(initializer, state, className);
      }
    },
    ClassAccessorProperty: function ClassAccessorProperty(path, state) {
      var node = path.node;
      var id = node.key;
      var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
      if (isAnonymous(initializer)) {
        if (!node.computed) {
          if (id.type === "Identifier") {
            visitor(initializer, state, id.name);
          } else if (id.type === "PrivateName") {
            var className = _core.types.stringLiteral("#" + id.id.name);
            visitor(initializer, state, className);
          } else {
            var _className3 = _core.types.stringLiteral(id.value + "");
            visitor(initializer, state, _className3);
          }
        } else {
          var ref = handleComputedProperty(path, id, state);
          visitor(initializer, state, ref);
        }
      }
    },
    ClassProperty: function ClassProperty(path, state) {
      var node = path.node;
      var id = node.key;
      var initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
      if (isAnonymous(initializer)) {
        if (!node.computed) {
          if (id.type === "Identifier") {
            visitor(initializer, state, id.name);
          } else {
            var className = _core.types.stringLiteral(id.value + "");
            visitor(initializer, state, className);
          }
        } else {
          var ref = handleComputedProperty(path, id, state);
          visitor(initializer, state, ref);
        }
      }
    }
  };
}
function isDecoratedAnonymousClassExpression(path) {
  return path.isClassExpression({
    id: null
  }) && shouldTransformClass(path.node);
}
function generateLetUidIdentifier(scope, name) {
  var id = scope.generateUidIdentifier(name);
  scope.push({
    id: id,
    kind: "let"
  });
  return _core.types.cloneNode(id);
}
function _default(_ref, _ref2, version, inherits) {
  var assertVersion = _ref.assertVersion,
    assumption = _ref.assumption;
  var loose = _ref2.loose;
  var _assumption, _assumption2;
  {
    if (version === "2023-11" || version === "2023-05" || version === "2023-01") {
      assertVersion("^7.21.0");
    } else if (version === "2021-12") {
      assertVersion("^7.16.0");
    } else {
      assertVersion("^7.19.0");
    }
  }
  var VISITED = new WeakSet();
  var constantSuper = (_assumption = assumption("constantSuper")) != null ? _assumption : loose;
  var ignoreFunctionLength = (_assumption2 = assumption("ignoreFunctionLength")) != null ? _assumption2 : loose;
  var namedEvaluationVisitor = NamedEvaluationVisitoryFactory(isDecoratedAnonymousClassExpression, visitClass);
  function visitClass(path, state, className) {
    var _className, _node$id;
    if (VISITED.has(path)) return;
    var node = path.node;
    (_className = className) != null ? _className : className = (_node$id = node.id) == null ? void 0 : _node$id.name;
    var newPath = transformClass(path, state, constantSuper, ignoreFunctionLength, className, namedEvaluationVisitor, version);
    if (newPath) {
      VISITED.add(newPath);
      return;
    }
    VISITED.add(path);
  }
  return {
    name: "proposal-decorators",
    inherits: inherits,
    visitor: Object.assign({
      ExportDefaultDeclaration: function ExportDefaultDeclaration(path, state) {
        var declaration = path.node.declaration;
        if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && isDecorated(declaration)) {
          var isAnonymous = !declaration.id;
          var updatedVarDeclarationPath = (0, _helperSplitExportDeclaration["default"])(path);
          if (isAnonymous) {
            visitClass(updatedVarDeclarationPath, state, _core.types.stringLiteral("default"));
          }
        }
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
        var declaration = path.node.declaration;
        if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && isDecorated(declaration)) {
          (0, _helperSplitExportDeclaration["default"])(path);
        }
      },
      Class: function Class(path, state) {
        visitClass(path, state, undefined);
      }
    }, namedEvaluationVisitor)
  };
}