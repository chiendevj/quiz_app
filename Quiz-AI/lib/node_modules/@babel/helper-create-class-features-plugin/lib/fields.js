"use strict";

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22;
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildCheckInRHS = buildCheckInRHS;
exports.buildFieldsInitNodes = buildFieldsInitNodes;
exports.buildPrivateNamesMap = buildPrivateNamesMap;
exports.buildPrivateNamesNodes = buildPrivateNamesNodes;
exports.privateNameVisitorFactory = privateNameVisitorFactory;
exports.transformPrivateNamesUsage = transformPrivateNamesUsage;
var _core = require("@babel/core");
var _helperReplaceSupers = require("@babel/helper-replace-supers");
var _helperEnvironmentVisitor = require("@babel/helper-environment-visitor");
var _helperMemberExpressionToFunctions = require("@babel/helper-member-expression-to-functions");
var _helperOptimiseCallExpression = require("@babel/helper-optimise-call-expression");
var _helperAnnotateAsPure = require("@babel/helper-annotate-as-pure");
var _helperSkipTransparentExpressionWrappers = require("@babel/helper-skip-transparent-expression-wrappers");
var ts = require("./typescript.js");
{
  var newHelpers = function newHelpers(file) {
    ;
    return file.availableHelper("classPrivateFieldGet2");
  };
}
function buildPrivateNamesMap(className, privateFieldsAsSymbolsOrProperties, props, file) {
  var privateNamesMap = new Map();
  var classBrandId;
  var _iterator = _createForOfIteratorHelper(props),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prop = _step.value;
      if (prop.isPrivate()) {
        var name = prop.node.key.id.name;
        var update = privateNamesMap.get(name);
        if (!update) {
          var isMethod = !prop.isProperty();
          var isStatic = prop.node["static"];
          var initAdded = false;
          var id = void 0;
          if (!privateFieldsAsSymbolsOrProperties && newHelpers(file) && isMethod && !isStatic) {
            var _classBrandId;
            initAdded = !!classBrandId;
            (_classBrandId = classBrandId) != null ? _classBrandId : classBrandId = prop.scope.generateUidIdentifier("".concat(className, "_brand"));
            id = classBrandId;
          } else {
            id = prop.scope.generateUidIdentifier(name);
          }
          update = {
            id: id,
            "static": isStatic,
            method: isMethod,
            initAdded: initAdded
          };
          privateNamesMap.set(name, update);
        }
        if (prop.isClassPrivateMethod()) {
          if (prop.node.kind === "get") {
            var body = prop.node.body.body;
            var $ = void 0;
            if (body.length === 1 && _core.types.isReturnStatement($ = body[0]) && _core.types.isCallExpression($ = $.argument) && $.arguments.length === 1 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($ = $.callee)) {
              update.getId = _core.types.cloneNode($);
              update.getterDeclared = true;
            } else {
              update.getId = prop.scope.generateUidIdentifier("get_".concat(name));
            }
          } else if (prop.node.kind === "set") {
            var params = prop.node.params;
            var _body = prop.node.body.body;
            var _$ = void 0;
            if (_body.length === 1 && _core.types.isExpressionStatement(_$ = _body[0]) && _core.types.isCallExpression(_$ = _$.expression) && _$.arguments.length === 2 && _core.types.isThisExpression(_$.arguments[0]) && _core.types.isIdentifier(_$.arguments[1], {
              name: params[0].name
            }) && _core.types.isIdentifier(_$ = _$.callee)) {
              update.setId = _core.types.cloneNode(_$);
              update.setterDeclared = true;
            } else {
              update.setId = prop.scope.generateUidIdentifier("set_".concat(name));
            }
          } else if (prop.node.kind === "method") {
            update.methodId = prop.scope.generateUidIdentifier(name);
          }
        }
        privateNamesMap.set(name, update);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return privateNamesMap;
}
function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {
  var initNodes = [];
  var injectedIds = new Set();
  var _iterator2 = _createForOfIteratorHelper(privateNamesMap),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        name = _step2$value[0],
        value = _step2$value[1];
      var isStatic = value["static"],
        isMethod = value.method,
        getId = value.getId,
        setId = value.setId;
      var isGetterOrSetter = getId || setId;
      var id = _core.types.cloneNode(value.id);
      var init = void 0;
      if (privateFieldsAsProperties) {
        init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]);
      } else if (privateFieldsAsSymbols) {
        init = _core.types.callExpression(_core.types.identifier("Symbol"), [_core.types.stringLiteral(name)]);
      } else if (!isStatic) {
        if (injectedIds.has(id.name)) continue;
        injectedIds.add(id.name);
        init = _core.types.newExpression(_core.types.identifier(isMethod && (!isGetterOrSetter || newHelpers(state)) ? "WeakSet" : "WeakMap"), []);
      }
      if (init) {
        if (!privateFieldsAsSymbols) {
          (0, _helperAnnotateAsPure["default"])(init);
        }
        initNodes.push(_core.template.statement.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["var ", " = ", ""])), id, init));
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return initNodes;
}
function privateNameVisitorFactory(visitor) {
  var nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor["default"]]);
  var privateNameVisitor = Object.assign({}, visitor, {
    Class: function Class(path) {
      var privateNamesMap = this.privateNamesMap;
      var body = path.get("body.body");
      var visiblePrivateNames = new Map(privateNamesMap);
      var redeclared = [];
      var _iterator3 = _createForOfIteratorHelper(body),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var prop = _step3.value;
          if (!prop.isPrivate()) continue;
          var name = prop.node.key.id.name;
          visiblePrivateNames["delete"](name);
          redeclared.push(name);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (!redeclared.length) {
        return;
      }
      path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
        redeclared: redeclared
      }));
      path.traverse(privateNameVisitor, Object.assign({}, this, {
        privateNamesMap: visiblePrivateNames
      }));
      path.skipKey("body");
    }
  });
  return privateNameVisitor;
}
var privateNameVisitor = privateNameVisitorFactory({
  PrivateName: function PrivateName(path, _ref3) {
    var noDocumentAll = _ref3.noDocumentAll;
    var privateNamesMap = this.privateNamesMap,
      redeclared = this.redeclared;
    var node = path.node,
      parentPath = path.parentPath;
    if (!parentPath.isMemberExpression({
      property: node
    }) && !parentPath.isOptionalMemberExpression({
      property: node
    })) {
      return;
    }
    var name = node.id.name;
    if (!privateNamesMap.has(name)) return;
    if (redeclared != null && redeclared.includes(name)) return;
    this.handle(parentPath, noDocumentAll);
  }
});
function unshadow(name, scope, innerBinding) {
  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {
    var _scope;
    scope.rename(name);
    scope = scope.parent;
  }
}
function buildCheckInRHS(rhs, file, inRHSIsObject) {
  if (inRHSIsObject || !(file.availableHelper != null && file.availableHelper("checkInRHS"))) return rhs;
  return _core.types.callExpression(file.addHelper("checkInRHS"), [rhs]);
}
var privateInVisitor = privateNameVisitorFactory({
  BinaryExpression: function BinaryExpression(path, _ref4) {
    var file = _ref4.file;
    var _path$node = path.node,
      operator = _path$node.operator,
      left = _path$node.left,
      right = _path$node.right;
    if (operator !== "in") return;
    if (!_core.types.isPrivateName(left)) return;
    var privateFieldsAsProperties = this.privateFieldsAsProperties,
      privateNamesMap = this.privateNamesMap,
      redeclared = this.redeclared;
    var name = left.id.name;
    if (!privateNamesMap.has(name)) return;
    if (redeclared != null && redeclared.includes(name)) return;
    unshadow(this.classRef.name, path.scope, this.innerBinding);
    if (privateFieldsAsProperties) {
      var _privateNamesMap$get = privateNamesMap.get(name),
        _id = _privateNamesMap$get.id;
      path.replaceWith(_core.template.expression.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        Object.prototype.hasOwnProperty.call(", ", ", ")\n      "])), buildCheckInRHS(right, file), _core.types.cloneNode(_id)));
      return;
    }
    var _privateNamesMap$get2 = privateNamesMap.get(name),
      id = _privateNamesMap$get2.id,
      isStatic = _privateNamesMap$get2["static"];
    if (isStatic) {
      path.replaceWith(_core.template.expression.ast(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["", " === ", ""])), buildCheckInRHS(right, file), _core.types.cloneNode(this.classRef)));
      return;
    }
    path.replaceWith(_core.template.expression.ast(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["", ".has(", ")"])), _core.types.cloneNode(id), buildCheckInRHS(right, file)));
  }
});
function readOnlyError(file, name) {
  return _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral("#".concat(name))]);
}
function writeOnlyError(file, name) {
  if (!file.availableHelper("writeOnlyError")) {
    console.warn("@babel/helpers is outdated, update it to silence this warning.");
    return _core.types.buildUndefinedNode();
  }
  return _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral("#".concat(name))]);
}
function buildStaticPrivateFieldAccess(expr, noUninitializedPrivateFieldAccess) {
  if (noUninitializedPrivateFieldAccess) return expr;
  return _core.types.memberExpression(expr, _core.types.identifier("_"));
}
function autoInherits(fn) {
  return function (member) {
    return _core.types.inherits(fn.apply(this, arguments), member.node);
  };
}
var privateNameHandlerSpec = {
  memoise: function memoise(member, count) {
    var scope = member.scope;
    var object = member.node.object;
    var memo = scope.maybeGenerateMemoised(object);
    if (!memo) {
      return;
    }
    this.memoiser.set(object, memo, count);
  },
  receiver: function receiver(member) {
    var object = member.node.object;
    if (this.memoiser.has(object)) {
      return _core.types.cloneNode(this.memoiser.get(object));
    }
    return _core.types.cloneNode(object);
  },
  get: autoInherits(function (member) {
    var classRef = this.classRef,
      privateNamesMap = this.privateNamesMap,
      file = this.file,
      innerBinding = this.innerBinding,
      noUninitializedPrivateFieldAccess = this.noUninitializedPrivateFieldAccess;
    var privateName = member.node.property;
    var name = privateName.id.name;
    var _privateNamesMap$get3 = privateNamesMap.get(name),
      id = _privateNamesMap$get3.id,
      isStatic = _privateNamesMap$get3["static"],
      isMethod = _privateNamesMap$get3.method,
      methodId = _privateNamesMap$get3.methodId,
      getId = _privateNamesMap$get3.getId,
      setId = _privateNamesMap$get3.setId;
    var isGetterOrSetter = getId || setId;
    var cloneId = function cloneId(id) {
      return _core.types.inherits(_core.types.cloneNode(id), privateName);
    };
    if (isStatic) {
      unshadow(classRef.name, member.scope, innerBinding);
      if (!newHelpers(file)) {
        var helperName = isMethod && !isGetterOrSetter ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]);
      }
      var receiver = this.receiver(member);
      var skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;
      if (!isMethod) {
        if (skipCheck) {
          return buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess);
        }
        return buildStaticPrivateFieldAccess(_core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]), noUninitializedPrivateFieldAccess);
      }
      if (getId) {
        if (skipCheck) {
          return _core.types.callExpression(cloneId(getId), [receiver]);
        }
        return _core.types.callExpression(file.addHelper("classPrivateGetter"), [_core.types.cloneNode(classRef), receiver, cloneId(getId)]);
      }
      if (setId) {
        var err = _core.types.buildUndefinedNode();
        if (skipCheck) return err;
        return _core.types.sequenceExpression([_core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver]), err]);
      }
      if (skipCheck) return cloneId(id);
      return _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]);
    }
    if (isMethod) {
      if (isGetterOrSetter) {
        if (!getId) {
          return _core.types.sequenceExpression([this.receiver(member), writeOnlyError(file, name)]);
        }
        if (!newHelpers(file)) {
          return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneId(id)]);
        }
        return _core.types.callExpression(file.addHelper("classPrivateGetter"), [_core.types.cloneNode(id), this.receiver(member), cloneId(getId)]);
      }
      if (!newHelpers(file)) {
        return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), cloneId(methodId)]);
      }
      return _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(id), this.receiver(member), cloneId(methodId)]);
    }
    if (newHelpers(file)) {
      return _core.types.callExpression(file.addHelper("classPrivateFieldGet2"), [cloneId(id), this.receiver(member)]);
    }
    return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneId(id)]);
  }),
  boundGet: function boundGet(member) {
    this.memoise(member, 1);
    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
  },
  set: autoInherits(function (member, value) {
    var classRef = this.classRef,
      privateNamesMap = this.privateNamesMap,
      file = this.file,
      noUninitializedPrivateFieldAccess = this.noUninitializedPrivateFieldAccess;
    var privateName = member.node.property;
    var name = privateName.id.name;
    var _privateNamesMap$get4 = privateNamesMap.get(name),
      id = _privateNamesMap$get4.id,
      isStatic = _privateNamesMap$get4["static"],
      isMethod = _privateNamesMap$get4.method,
      setId = _privateNamesMap$get4.setId,
      getId = _privateNamesMap$get4.getId;
    var isGetterOrSetter = getId || setId;
    var cloneId = function cloneId(id) {
      return _core.types.inherits(_core.types.cloneNode(id), privateName);
    };
    if (isStatic) {
      if (!newHelpers(file)) {
        var helperName = isMethod && !isGetterOrSetter ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id), value]);
      }
      var receiver = this.receiver(member);
      var skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;
      if (isMethod && !setId) {
        var err = readOnlyError(file, name);
        if (skipCheck) return _core.types.sequenceExpression([value, err]);
        return _core.types.sequenceExpression([value, _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver]), readOnlyError(file, name)]);
      }
      if (setId) {
        if (skipCheck) {
          return _core.types.callExpression(_core.types.cloneNode(setId), [receiver, value]);
        }
        return _core.types.callExpression(file.addHelper("classPrivateSetter"), [_core.types.cloneNode(classRef), cloneId(setId), receiver, value]);
      }
      return _core.types.assignmentExpression("=", buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess), skipCheck ? value : _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, value]));
    }
    if (isMethod) {
      if (setId) {
        if (!newHelpers(file)) {
          return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneId(id), value]);
        }
        return _core.types.callExpression(file.addHelper("classPrivateSetter"), [_core.types.cloneNode(id), cloneId(setId), this.receiver(member), value]);
      }
      return _core.types.sequenceExpression([this.receiver(member), value, readOnlyError(file, name)]);
    }
    if (newHelpers(file)) {
      return _core.types.callExpression(file.addHelper("classPrivateFieldSet2"), [cloneId(id), this.receiver(member), value]);
    }
    return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneId(id), value]);
  }),
  destructureSet: function destructureSet(member) {
    var classRef = this.classRef,
      privateNamesMap = this.privateNamesMap,
      file = this.file,
      noUninitializedPrivateFieldAccess = this.noUninitializedPrivateFieldAccess;
    var privateName = member.node.property;
    var name = privateName.id.name;
    var _privateNamesMap$get5 = privateNamesMap.get(name),
      id = _privateNamesMap$get5.id,
      isStatic = _privateNamesMap$get5["static"],
      isMethod = _privateNamesMap$get5.method,
      setId = _privateNamesMap$get5.setId;
    var cloneId = function cloneId(id) {
      return _core.types.inherits(_core.types.cloneNode(id), privateName);
    };
    if (!newHelpers(file)) {
      if (isStatic) {
        try {
          var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
        } catch (_unused) {
          throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n" + "please update @babel/helpers to the latest version.");
        }
        return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]), _core.types.identifier("value"));
      }
      return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneId(id)]), _core.types.identifier("value"));
    }
    if (isMethod && !setId) {
      return _core.types.memberExpression(_core.types.sequenceExpression([member.node.object, readOnlyError(file, name)]), _core.types.identifier("_"));
    }
    if (isStatic && !isMethod) {
      var getCall = this.get(member);
      if (!noUninitializedPrivateFieldAccess || !_core.types.isCallExpression(getCall)) {
        return getCall;
      }
      var ref = getCall.arguments.pop();
      getCall.arguments.push(_core.template.expression.ast(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["(_) => ", " = _"])), ref));
      return _core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"), [getCall]), _core.types.identifier("_"));
    }
    var setCall = this.set(member, _core.types.identifier("_"));
    if (!_core.types.isCallExpression(setCall) || !_core.types.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {
      name: "_"
    })) {
      throw member.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. " + "Please report it at https://github.com/babel/babel/issues.");
    }
    var args;
    if (_core.types.isMemberExpression(setCall.callee, {
      computed: false
    }) && _core.types.isIdentifier(setCall.callee.property) && setCall.callee.property.name === "call") {
      args = [setCall.callee.object, _core.types.arrayExpression(setCall.arguments.slice(1, -1)), setCall.arguments[0]];
    } else {
      args = [setCall.callee, _core.types.arrayExpression(setCall.arguments.slice(0, -1))];
    }
    return _core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"), args), _core.types.identifier("_"));
  },
  call: function call(member, args) {
    this.memoise(member, 1);
    return (0, _helperOptimiseCallExpression["default"])(this.get(member), this.receiver(member), args, false);
  },
  optionalCall: function optionalCall(member, args) {
    this.memoise(member, 1);
    return (0, _helperOptimiseCallExpression["default"])(this.get(member), this.receiver(member), args, true);
  },
  "delete": function _delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  }
};
var privateNameHandlerLoose = {
  get: function get(member) {
    var privateNamesMap = this.privateNamesMap,
      file = this.file;
    var object = member.node.object;
    var name = member.node.property.id.name;
    return _core.template.expression(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["BASE(REF, PROP)[PROP]"])))({
      BASE: file.addHelper("classPrivateFieldLooseBase"),
      REF: _core.types.cloneNode(object),
      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
    });
  },
  set: function set() {
    throw new Error("private name handler with loose = true don't need set()");
  },
  boundGet: function boundGet(member) {
    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
  },
  simpleSet: function simpleSet(member) {
    return this.get(member);
  },
  destructureSet: function destructureSet(member) {
    return this.get(member);
  },
  call: function call(member, args) {
    return _core.types.callExpression(this.get(member), args);
  },
  optionalCall: function optionalCall(member, args) {
    return _core.types.optionalCallExpression(this.get(member), args, true);
  },
  "delete": function _delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  }
};
function transformPrivateNamesUsage(ref, path, privateNamesMap, _ref5, state) {
  var privateFieldsAsProperties = _ref5.privateFieldsAsProperties,
    noUninitializedPrivateFieldAccess = _ref5.noUninitializedPrivateFieldAccess,
    noDocumentAll = _ref5.noDocumentAll,
    innerBinding = _ref5.innerBinding;
  if (!privateNamesMap.size) return;
  var body = path.get("body");
  var handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
  (0, _helperMemberExpressionToFunctions["default"])(body, privateNameVisitor, Object.assign({
    privateNamesMap: privateNamesMap,
    classRef: ref,
    file: state
  }, handler, {
    noDocumentAll: noDocumentAll,
    noUninitializedPrivateFieldAccess: noUninitializedPrivateFieldAccess,
    innerBinding: innerBinding
  }));
  body.traverse(privateInVisitor, {
    privateNamesMap: privateNamesMap,
    classRef: ref,
    file: state,
    privateFieldsAsProperties: privateFieldsAsProperties,
    innerBinding: innerBinding
  });
}
function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
  var _privateNamesMap$get6 = privateNamesMap.get(prop.node.key.id.name),
    id = _privateNamesMap$get6.id;
  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(_core.template.statement.ast(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ", "\n      });\n    "])), ref, _core.types.cloneNode(id), value), prop);
}
function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
  var _privateNamesMap$get7 = privateNamesMap.get(prop.node.key.id.name),
    id = _privateNamesMap$get7.id;
  var value = prop.node.value || prop.scope.buildUndefinedNode();
  {
    if (!state.availableHelper("classPrivateFieldInitSpec")) {
      return inheritPropComments(_core.template.statement.ast(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["", ".set(", ", {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ", ",\n        })"])), _core.types.cloneNode(id), ref, value), prop);
    }
  }
  var helper = state.addHelper("classPrivateFieldInitSpec");
  return inheritLoc(inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(helper, [_core.types.thisExpression(), inheritLoc(_core.types.cloneNode(id), prop.node.key), newHelpers(state) ? value : _core.template.expression.ast(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["{ writable: true, value: ", " }"])), value)])), prop), prop.node);
}
function buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var value = noUninitializedPrivateFieldAccess ? prop.node.value : _core.template.expression.ast(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["{\n        _: ", "\n      }"])), prop.node.value || _core.types.buildUndefinedNode());
  return inheritPropComments(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.cloneNode(privateName.id), value)]), prop);
}
{
  var buildPrivateStaticFieldInitSpecOld = function buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
      getId = privateName.getId,
      setId = privateName.setId,
      initAdded = privateName.initAdded;
    var isGetterOrSetter = getId || setId;
    if (!prop.isProperty() && (initAdded || !isGetterOrSetter)) return;
    if (isGetterOrSetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return inheritPropComments(_core.template.statement.ast(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n          var ", " = {\n            // configurable is false by default\n            // enumerable is false by default\n            // writable is false by default\n            get: ", ",\n            set: ", "\n          }\n        "])), _core.types.cloneNode(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode()), prop);
    }
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return inheritPropComments(_core.template.statement.ast(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["\n        var ", " = {\n          // configurable is false by default\n          // enumerable is false by default\n          writable: true,\n          value: ", "\n        };\n      "])), _core.types.cloneNode(id), value), prop);
  };
}
function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var methodId = privateName.methodId,
    id = privateName.id,
    getId = privateName.getId,
    setId = privateName.setId,
    initAdded = privateName.initAdded;
  if (initAdded) return;
  if (methodId) {
    return inheritPropComments(_core.template.statement.ast(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "])), ref, id, methodId.name), prop);
  }
  var isGetterOrSetter = getId || setId;
  if (isGetterOrSetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    return inheritPropComments(_core.template.statement.ast(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ", ",\n          set: ", "\n        });\n      "])), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode()), prop);
  }
}
function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  if (privateName.initAdded) return;
  if (!newHelpers(state)) {
    var isGetterOrSetter = privateName.getId || privateName.setId;
    if (isGetterOrSetter) {
      return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);
    }
  }
  return buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);
}
function buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
    getId = privateName.getId,
    setId = privateName.setId;
  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
    initAdded: true
  }));
  {
    if (!state.availableHelper("classPrivateFieldInitSpec")) {
      return inheritPropComments(_core.template.statement.ast(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral(["\n          ", ".set(", ", {\n            get: ", ",\n            set: ", "\n          });\n        "])), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode()), prop);
    }
  }
  var helper = state.addHelper("classPrivateFieldInitSpec");
  return inheritLoc(inheritPropComments(_core.template.statement.ast(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral(["", "(\n      ", ",\n      ", ",\n      {\n        get: ", ",\n        set: ", "\n      },\n    )"])), helper, _core.types.thisExpression(), _core.types.cloneNode(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode()), prop), prop.node);
}
function buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id;
  {
    if (!state.availableHelper("classPrivateMethodInitSpec")) {
      return inheritPropComments(_core.template.statement.ast(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral(["", ".add(", ")"])), id, ref), prop);
    }
  }
  var helper = state.addHelper("classPrivateMethodInitSpec");
  return inheritPropComments(_core.template.statement.ast(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral(["", "(\n      ", ",\n      ", "\n    )"])), helper, _core.types.thisExpression(), _core.types.cloneNode(id)), prop);
}
function buildPublicFieldInitLoose(ref, prop) {
  var _prop$node = prop.node,
    key = _prop$node.key,
    computed = _prop$node.computed;
  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value)), prop);
}
function buildPublicFieldInitSpec(ref, prop, state) {
  var _prop$node2 = prop.node,
    key = _prop$node2.key,
    computed = _prop$node2.computed;
  var value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value])), prop);
}
function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
    methodId = privateName.methodId,
    getId = privateName.getId,
    setId = privateName.setId,
    initAdded = privateName.initAdded;
  if (initAdded) return;
  var isGetterOrSetter = getId || setId;
  if (isGetterOrSetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    return inheritPropComments(_core.template.statement.ast(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ", ",\n          set: ", "\n        })\n      "])), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode()), prop);
  }
  return inheritPropComments(_core.template.statement.ast(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ", "\n      });\n    "])), ref, id, methodId.name), prop);
}
function buildPrivateMethodDeclaration(file, prop, privateNamesMap) {
  var privateFieldsAsSymbolsOrProperties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var privateName = privateNamesMap.get(prop.node.key.id.name);
  var id = privateName.id,
    methodId = privateName.methodId,
    getId = privateName.getId,
    setId = privateName.setId,
    getterDeclared = privateName.getterDeclared,
    setterDeclared = privateName.setterDeclared,
    isStatic = privateName["static"];
  var _prop$node3 = prop.node,
    params = _prop$node3.params,
    body = _prop$node3.body,
    generator = _prop$node3.generator,
    async = _prop$node3.async;
  var isGetter = getId && params.length === 0;
  var isSetter = setId && params.length > 0;
  if (isGetter && getterDeclared || isSetter && setterDeclared) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: true
    }));
    return null;
  }
  if (newHelpers(file) && (isGetter || isSetter) && !privateFieldsAsSymbolsOrProperties) {
    var scope = prop.get("body").scope;
    var thisArg = scope.generateUidIdentifier("this");
    var state = {
      thisRef: thisArg,
      argumentsPath: []
    };
    prop.traverse(thisContextVisitor, state);
    if (state.argumentsPath.length) {
      var argumentsId = scope.generateUidIdentifier("arguments");
      scope.push({
        id: argumentsId,
        init: _core.template.expression.ast(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral(["[].slice.call(arguments, 1)"])))
      });
      var _iterator4 = _createForOfIteratorHelper(state.argumentsPath),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var path = _step4.value;
          path.replaceWith(_core.types.cloneNode(argumentsId));
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
    params.unshift(_core.types.cloneNode(thisArg));
  }
  var declId = methodId;
  if (isGetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      getterDeclared: true,
      initAdded: true
    }));
    declId = getId;
  } else if (isSetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      setterDeclared: true,
      initAdded: true
    }));
    declId = setId;
  } else if (isStatic && !privateFieldsAsSymbolsOrProperties) {
    declId = id;
  }
  return inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);
}
var thisContextVisitor = _core.traverse.visitors.merge([{
  Identifier: function Identifier(path, state) {
    if (state.argumentsPath && path.node.name === "arguments") {
      state.argumentsPath.push(path);
    }
  },
  UnaryExpression: function UnaryExpression(path) {
    var node = path.node;
    if (node.operator === "delete") {
      var argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);
      if (_core.types.isThisExpression(argument)) {
        path.replaceWith(_core.types.booleanLiteral(true));
      }
    }
  },
  ThisExpression: function ThisExpression(path, state) {
    state.needsClassRef = true;
    path.replaceWith(_core.types.cloneNode(state.thisRef));
  },
  MetaProperty: function MetaProperty(path) {
    var node = path.node,
      scope = path.scope;
    if (node.meta.name === "new" && node.property.name === "target") {
      path.replaceWith(scope.buildUndefinedNode());
    }
  }
}, _helperEnvironmentVisitor["default"]]);
var innerReferencesVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {
      state.needsClassRef = true;
      path.node.name = state.thisRef.name;
    }
  }
};
function replaceThisContext(path, ref, innerBindingRef) {
  var _state$thisRef;
  var state = {
    thisRef: ref,
    needsClassRef: false,
    innerBinding: innerBindingRef
  };
  if (!path.isMethod()) {
    path.traverse(thisContextVisitor, state);
  }
  if (innerBindingRef != null && (_state$thisRef = state.thisRef) != null && _state$thisRef.name && state.thisRef.name !== innerBindingRef.name) {
    path.traverse(innerReferencesVisitor, state);
  }
  return state.needsClassRef;
}
function isNameOrLength(_ref6) {
  var key = _ref6.key,
    computed = _ref6.computed;
  if (key.type === "Identifier") {
    return !computed && (key.name === "name" || key.name === "length");
  }
  if (key.type === "StringLiteral") {
    return key.value === "name" || key.value === "length";
  }
  return false;
}
function inheritPropComments(node, prop) {
  _core.types.inheritLeadingComments(node, prop.node);
  _core.types.inheritInnerComments(node, prop.node);
  return node;
}
function inheritLoc(node, original) {
  node.start = original.start;
  node.end = original.end;
  node.loc = original.loc;
  return node;
}
function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, file, setPublicClassFields, privateFieldsAsSymbolsOrProperties, noUninitializedPrivateFieldAccess, constantSuper, innerBindingRef) {
  var _ref, _ref2;
  var classRefFlags = 0;
  var injectSuperRef;
  var staticNodes = [];
  var instanceNodes = [];
  var lastInstanceNodeReturnsThis = false;
  var pureStaticNodes = [];
  var classBindingNode = null;
  var getSuperRef = _core.types.isIdentifier(superRef) ? function () {
    return superRef;
  } : function () {
    var _injectSuperRef;
    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);
    return injectSuperRef;
  };
  var classRefForInnerBinding = (_ref = ref) != null ? _ref : props[0].scope.generateUidIdentifier((innerBindingRef == null ? void 0 : innerBindingRef.name) || "Class");
  (_ref2 = ref) != null ? _ref2 : ref = _core.types.cloneNode(innerBindingRef);
  var _iterator5 = _createForOfIteratorHelper(props),
    _step5;
  try {
    var _loop = function _loop() {
      var prop = _step5.value;
      prop.isClassProperty() && ts.assertFieldTransformed(prop);
      var isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node["static"];
      var isInstance = !isStatic;
      var isPrivate = prop.isPrivate();
      var isPublic = !isPrivate;
      var isField = prop.isProperty();
      var isMethod = !isField;
      var isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();
      if (isStatic) classRefFlags |= 1;
      if (isStatic || isMethod && isPrivate || isStaticBlock) {
        new _helperReplaceSupers["default"]({
          methodPath: prop,
          constantSuper: constantSuper,
          file: file,
          refToPreserve: innerBindingRef,
          getSuperRef: getSuperRef,
          getObjectRef: function getObjectRef() {
            classRefFlags |= 2;
            if (isStatic || isStaticBlock) {
              return classRefForInnerBinding;
            } else {
              return _core.types.memberExpression(classRefForInnerBinding, _core.types.identifier("prototype"));
            }
          }
        }).replace();
        var replaced = replaceThisContext(prop, classRefForInnerBinding, innerBindingRef);
        if (replaced) {
          classRefFlags |= 2;
        }
      }
      lastInstanceNodeReturnsThis = false;
      switch (true) {
        case isStaticBlock:
          {
            var blockBody = prop.node.body;
            if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {
              staticNodes.push(inheritPropComments(blockBody[0], prop));
            } else {
              staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral(["(() => { ", " })()"])), blockBody), prop.node));
            }
            break;
          }
        case isStatic && isPrivate && isField && privateFieldsAsSymbolsOrProperties:
          staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
          break;
        case isStatic && isPrivate && isField && !privateFieldsAsSymbolsOrProperties:
          if (!newHelpers(file)) {
            staticNodes.push(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));
          } else {
            staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess));
          }
          break;
        case isStatic && isPublic && isField && setPublicClassFields:
          if (!isNameOrLength(prop.node)) {
            staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
            break;
          }
        case isStatic && isPublic && isField && !setPublicClassFields:
          staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, file));
          break;
        case isInstance && isPrivate && isField && privateFieldsAsSymbolsOrProperties:
          instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
          break;
        case isInstance && isPrivate && isField && !privateFieldsAsSymbolsOrProperties:
          instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
          break;
        case isInstance && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties:
          instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
          break;
        case isInstance && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties:
          instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
          pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
          break;
        case isStatic && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties:
          if (!newHelpers(file)) {
            staticNodes.unshift(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));
          }
          pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
          break;
        case isStatic && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties:
          staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, file, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
          break;
        case isInstance && isPublic && isField && setPublicClassFields:
          instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
          break;
        case isInstance && isPublic && isField && !setPublicClassFields:
          lastInstanceNodeReturnsThis = true;
          instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, file));
          break;
        default:
          throw new Error("Unreachable.");
      }
    };
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (classRefFlags & 2 && innerBindingRef != null) {
    classBindingNode = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classRefForInnerBinding), _core.types.cloneNode(innerBindingRef)));
  }
  return {
    staticNodes: staticNodes.filter(Boolean),
    instanceNodes: instanceNodes.filter(Boolean),
    lastInstanceNodeReturnsThis: lastInstanceNodeReturnsThis,
    pureStaticNodes: pureStaticNodes.filter(Boolean),
    classBindingNode: classBindingNode,
    wrapClass: function wrapClass(path) {
      var _iterator6 = _createForOfIteratorHelper(props),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var prop = _step6.value;
          prop.node.leadingComments = null;
          prop.remove();
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      if (injectSuperRef) {
        path.scope.push({
          id: _core.types.cloneNode(injectSuperRef)
        });
        path.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path.node.superClass));
      }
      if (classRefFlags !== 0) {
        if (path.isClassExpression()) {
          path.scope.push({
            id: ref
          });
          path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node));
        } else {
          if (innerBindingRef == null) {
            path.node.id = ref;
          }
          if (classBindingNode != null) {
            path.scope.push({
              id: classRefForInnerBinding
            });
          }
        }
      }
      return path;
    }
  };
}