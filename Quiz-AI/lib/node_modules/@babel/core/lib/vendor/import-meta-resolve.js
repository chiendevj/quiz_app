"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moduleResolve = moduleResolve;
exports.resolve = resolve;
function _assert() {
  var data = require("assert");
  _assert = function _assert() {
    return data;
  };
  return data;
}
function _fs() {
  var data = _interopRequireWildcard(require("fs"), true);
  _fs = function _fs() {
    return data;
  };
  return data;
}
function _process() {
  var data = require("process");
  _process = function _process() {
    return data;
  };
  return data;
}
function _url() {
  var data = require("url");
  _url = function _url() {
    return data;
  };
  return data;
}
function _path() {
  var data = require("path");
  _path = function _path() {
    return data;
  };
  return data;
}
function _module() {
  var data = require("module");
  _module = function _module() {
    return data;
  };
  return data;
}
function _v() {
  var data = require("v8");
  _v = function _v() {
    return data;
  };
  return data;
}
function _util() {
  var data = require("util");
  _util = function _util() {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
    "default": e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n["default"] = e, t && t.set(e, n), n;
}
var own$1 = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = new Set(['string', 'function', 'number', 'object', 'Function', 'Object', 'boolean', 'bigint', 'symbol']);
var codes = {};
function formatList(array) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'and';
  return array.length < 3 ? array.join(" ".concat(type, " ")) : "".concat(array.slice(0, -1).join(', '), ", ").concat(type, " ").concat(array[array.length - 1]);
}
var messages = new Map();
var nodeInternalPrefix = '__node_internal_';
var userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  _assert()(typeof name === 'string', "'name' must be a string");
  if (!Array.isArray(expected)) {
    expected = [expected];
  }
  var message = 'The ';
  if (name.endsWith(' argument')) {
    message += "".concat(name, " ");
  } else {
    var type = name.includes('.') ? 'property' : 'argument';
    message += "\"".concat(name, "\" ").concat(type, " ");
  }
  message += 'must be ';
  var types = [];
  var instances = [];
  var other = [];
  var _iterator = _createForOfIteratorHelper(expected),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      _assert()(typeof value === 'string', 'All expected entries have to be of type string');
      if (kTypes.has(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        _assert()(value !== 'object', 'The value "object" should be written as "Object"');
        other.push(value);
      } else {
        instances.push(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (instances.length > 0) {
    var pos = types.indexOf('object');
    if (pos !== -1) {
      types.slice(pos, 1);
      instances.push('Object');
    }
  }
  if (types.length > 0) {
    message += "".concat(types.length > 1 ? 'one of type' : 'of type', " ").concat(formatList(types, 'or'));
    if (instances.length > 0 || other.length > 0) message += ' or ';
  }
  if (instances.length > 0) {
    message += "an instance of ".concat(formatList(instances, 'or'));
    if (other.length > 0) message += ' or ';
  }
  if (other.length > 0) {
    if (other.length > 1) {
      message += "one of ".concat(formatList(other, 'or'));
    } else {
      if (other[0].toLowerCase() !== other[0]) message += 'an ';
      message += "".concat(other[0]);
    }
  }
  message += ". Received ".concat(determineSpecificType(actual));
  return message;
}, TypeError);
codes.ERR_INVALID_MODULE_SPECIFIER = createError('ERR_INVALID_MODULE_SPECIFIER', function (request, reason) {
  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return "Invalid module \"".concat(request, "\" ").concat(reason).concat(base ? " imported from ".concat(base) : '');
}, TypeError);
codes.ERR_INVALID_PACKAGE_CONFIG = createError('ERR_INVALID_PACKAGE_CONFIG', function (path, base, message) {
  return "Invalid package config ".concat(path).concat(base ? " while importing ".concat(base) : '').concat(message ? ". ".concat(message) : '');
}, Error);
codes.ERR_INVALID_PACKAGE_TARGET = createError('ERR_INVALID_PACKAGE_TARGET', function (packagePath, key, target) {
  var isImport = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var base = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  var relatedError = typeof target === 'string' && !isImport && target.length > 0 && !target.startsWith('./');
  if (key === '.') {
    _assert()(isImport === false);
    return "Invalid \"exports\" main target ".concat(JSON.stringify(target), " defined ") + "in the package config ".concat(packagePath, "package.json").concat(base ? " imported from ".concat(base) : '').concat(relatedError ? '; targets must start with "./"' : '');
  }
  return "Invalid \"".concat(isImport ? 'imports' : 'exports', "\" target ").concat(JSON.stringify(target), " defined for '").concat(key, "' in the package config ").concat(packagePath, "package.json").concat(base ? " imported from ".concat(base) : '').concat(relatedError ? '; targets must start with "./"' : '');
}, Error);
codes.ERR_MODULE_NOT_FOUND = createError('ERR_MODULE_NOT_FOUND', function (path, base) {
  var exactUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return "Cannot find ".concat(exactUrl ? 'module' : 'package', " '").concat(path, "' imported from ").concat(base);
}, Error);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError('ERR_NETWORK_IMPORT_DISALLOWED', "import of '%s' by %s is not supported: %s", Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError('ERR_PACKAGE_IMPORT_NOT_DEFINED', function (specifier, packagePath, base) {
  return "Package import specifier \"".concat(specifier, "\" is not defined").concat(packagePath ? " in package ".concat(packagePath, "package.json") : '', " imported from ").concat(base);
}, TypeError);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError('ERR_PACKAGE_PATH_NOT_EXPORTED', function (packagePath, subpath) {
  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  if (subpath === '.') return "No \"exports\" main defined in ".concat(packagePath, "package.json").concat(base ? " imported from ".concat(base) : '');
  return "Package subpath '".concat(subpath, "' is not defined by \"exports\" in ").concat(packagePath, "package.json").concat(base ? " imported from ".concat(base) : '');
}, Error);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError('ERR_UNSUPPORTED_DIR_IMPORT', "Directory import '%s' is not supported " + 'resolving ES modules imported from %s', Error);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError('ERR_UNSUPPORTED_RESOLVE_REQUEST', 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError('ERR_UNKNOWN_FILE_EXTENSION', function (extension, path) {
  return "Unknown file extension \"".concat(extension, "\" for ").concat(path);
}, TypeError);
codes.ERR_INVALID_ARG_VALUE = createError('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  var inspected = (0, _util().inspect)(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  var type = name.includes('.') ? 'property' : 'argument';
  return "The ".concat(type, " '").concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError);
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError() {
    var limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    var error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {
      parameters[_key] = arguments[_key];
    }
    var message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        value: function value() {
          return "".concat(this.name, " [").concat(key, "]: ").concat(this.message);
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (_v().startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch (_unused) {}
  var desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');
  if (desc === undefined) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, 'writable') && desc.writable !== undefined ? desc.writable : desc.set !== undefined;
}
function hideStackFrames(wrappedFunction) {
  var hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, 'name', {
    value: hidden
  });
  return wrappedFunction;
}
var captureLargerStackTrace = hideStackFrames(function (error) {
  var stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, parameters, self) {
  var message = messages.get(key);
  _assert()(message !== undefined, 'expected `message` to be found');
  if (typeof message === 'function') {
    _assert()(message.length <= parameters.length, "Code: ".concat(key, "; The provided arguments length (").concat(parameters.length, ") does not ") + "match the required ones (".concat(message.length, ")."));
    return Reflect.apply(message, self, parameters);
  }
  var regex = /%[dfijoOs]/g;
  var expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  _assert()(expectedLength === parameters.length, "Code: ".concat(key, "; The provided arguments length (").concat(parameters.length, ") does not ") + "match the required ones (".concat(expectedLength, ")."));
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(_util().format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === undefined) {
    return String(value);
  }
  if (typeof value === 'function' && value.name) {
    return "function ".concat(value.name);
  }
  if (_typeof(value) === 'object') {
    if (value.constructor && value.constructor.name) {
      return "an instance of ".concat(value.constructor.name);
    }
    return "".concat((0, _util().inspect)(value, {
      depth: -1
    }));
  }
  var inspected = (0, _util().inspect)(value, {
    colors: false
  });
  if (inspected.length > 28) {
    inspected = "".concat(inspected.slice(0, 25), "...");
  }
  return "type ".concat(_typeof(value), " (").concat(inspected, ")");
}
var hasOwnProperty$1 = {}.hasOwnProperty;
var ERR_INVALID_PACKAGE_CONFIG$1 = codes.ERR_INVALID_PACKAGE_CONFIG;
var cache = new Map();
function read(jsonPath, _ref) {
  var base = _ref.base,
    specifier = _ref.specifier;
  var existing = cache.get(jsonPath);
  if (existing) {
    return existing;
  }
  var string;
  try {
    string = _fs()["default"].readFileSync(_path().toNamespacedPath(jsonPath), 'utf8');
  } catch (error) {
    var exception = error;
    if (exception.code !== 'ENOENT') {
      throw exception;
    }
  }
  var result = {
    exists: false,
    pjsonPath: jsonPath,
    main: undefined,
    name: undefined,
    type: 'none',
    exports: undefined,
    imports: undefined
  };
  if (string !== undefined) {
    var parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      var cause = error_;
      var error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? "\"".concat(specifier, "\" from ") : '') + (0, _url().fileURLToPath)(base || specifier), cause.message);
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty$1.call(parsed, 'name') && typeof parsed.name === 'string') {
      result.name = parsed.name;
    }
    if (hasOwnProperty$1.call(parsed, 'main') && typeof parsed.main === 'string') {
      result.main = parsed.main;
    }
    if (hasOwnProperty$1.call(parsed, 'exports')) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty$1.call(parsed, 'imports')) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty$1.call(parsed, 'type') && (parsed.type === 'commonjs' || parsed.type === 'module')) {
      result.type = parsed.type;
    }
  }
  cache.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  var packageJSONUrl = new URL('package.json', resolved);
  while (true) {
    var _packageJSONPath = packageJSONUrl.pathname;
    if (_packageJSONPath.endsWith('node_modules/package.json')) {
      break;
    }
    var packageConfig = read((0, _url().fileURLToPath)(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    var lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL('../package.json', packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  var packageJSONPath = (0, _url().fileURLToPath)(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: 'none'
  };
}
function getPackageType(url) {
  return getPackageScopeConfig(url).type;
}
var ERR_UNKNOWN_FILE_EXTENSION = codes.ERR_UNKNOWN_FILE_EXTENSION;
var hasOwnProperty = {}.hasOwnProperty;
var extensionFormatMap = {
  __proto__: null,
  '.cjs': 'commonjs',
  '.js': 'module',
  '.json': 'json',
  '.mjs': 'module'
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return 'module';
  if (mime === 'application/json') return 'json';
  return null;
}
var protocolHandlers = {
  __proto__: null,
  'data:': getDataProtocolModuleFormat,
  'file:': getFileProtocolModuleFormat,
  'http:': getHttpProtocolModuleFormat,
  'https:': getHttpProtocolModuleFormat,
  'node:': function node() {
    return 'builtin';
  }
};
function getDataProtocolModuleFormat(parsed) {
  var _ref2 = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null],
    mime = _ref2[1];
  return mimeToFormat(mime);
}
function extname(url) {
  var pathname = url.pathname;
  var index = pathname.length;
  while (index--) {
    var code = pathname.codePointAt(index);
    if (code === 47) {
      return '';
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? '' : pathname.slice(index);
    }
  }
  return '';
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  var value = extname(url);
  if (value === '.js') {
    var packageType = getPackageType(url);
    if (packageType !== 'none') {
      return packageType;
    }
    return 'commonjs';
  }
  if (value === '') {
    var _packageType = getPackageType(url);
    if (_packageType === 'none' || _packageType === 'commonjs') {
      return 'commonjs';
    }
    return 'module';
  }
  var format = extensionFormatMap[value];
  if (format) return format;
  if (ignoreErrors) {
    return undefined;
  }
  var filepath = (0, _url().fileURLToPath)(url);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {}
function defaultGetFormatWithoutErrors(url, context) {
  var protocol = url.protocol;
  if (!hasOwnProperty.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url, context, true) || null;
}
var ERR_INVALID_ARG_VALUE = codes.ERR_INVALID_ARG_VALUE;
var DEFAULT_CONDITIONS = Object.freeze(['node', 'import']);
var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== undefined && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var ERR_NETWORK_IMPORT_DISALLOWED = codes.ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER = codes.ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG = codes.ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET = codes.ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND = codes.ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED = codes.ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED = codes.ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT = codes.ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_RESOLVE_REQUEST = codes.ERR_UNSUPPORTED_RESOLVE_REQUEST;
var own = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSeparatorRegEx = /%2f|%5c/i;
var emittedPackageWarnings = new Set();
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (_process().noDeprecation) {
    return;
  }
  var pjsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  var _double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  _process().emitWarning("Use of deprecated ".concat(_double ? 'double slash' : 'leading or trailing slash matching', " resolving \"").concat(target, "\" for module ") + "request \"".concat(request, "\" ").concat(request === match ? '' : "matched to \"".concat(match, "\" "), "in the \"").concat(internal ? 'imports' : 'exports', "\" field module resolution of the package at ").concat(pjsonPath).concat(base ? " imported from ".concat((0, _url().fileURLToPath)(base)) : '', "."), 'DeprecationWarning', 'DEP0166');
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  if (_process().noDeprecation) {
    return;
  }
  var format = defaultGetFormatWithoutErrors(url, {
    parentURL: base.href
  });
  if (format !== 'module') return;
  var urlPath = (0, _url().fileURLToPath)(url.href);
  var packagePath = (0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl));
  var basePath = (0, _url().fileURLToPath)(base);
  if (!main) {
    _process().emitWarning("No \"main\" or \"exports\" field defined in the package.json for ".concat(packagePath, " resolving the main entry point \"").concat(urlPath.slice(packagePath.length), "\", imported from ").concat(basePath, ".\nDefault \"index\" lookups for the main are deprecated for ES modules."), 'DeprecationWarning', 'DEP0151');
  } else if (_path().resolve(packagePath, main) !== urlPath) {
    _process().emitWarning("Package ".concat(packagePath, " has a \"main\" field set to \"").concat(main, "\", ") + "excluding the full filename and extension to the resolved file at \"".concat(urlPath.slice(packagePath.length), "\", imported from ").concat(basePath, ".\n Automatic extension resolution of the \"main\" field is ") + 'deprecated for ES modules.', 'DeprecationWarning', 'DEP0151');
  }
}
function tryStatSync(path) {
  try {
    return (0, _fs().statSync)(path);
  } catch (_unused2) {}
}
function fileExists(url) {
  var stats = (0, _fs().statSync)(url, {
    throwIfNoEntry: false
  });
  var isFile = stats ? stats.isFile() : undefined;
  return isFile === null || isFile === undefined ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  var guess;
  if (packageConfig.main !== undefined) {
    guess = new (_url().URL)(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    var _tries = ["./".concat(packageConfig.main, ".js"), "./".concat(packageConfig.main, ".json"), "./".concat(packageConfig.main, ".node"), "./".concat(packageConfig.main, "/index.js"), "./".concat(packageConfig.main, "/index.json"), "./".concat(packageConfig.main, "/index.node")];
    var _i = -1;
    while (++_i < _tries.length) {
      guess = new (_url().URL)(_tries[_i], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = undefined;
    }
    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
  }
  var tries = ['./index.js', './index.json', './index.node'];
  var i = -1;
  while (++i < tries.length) {
    guess = new (_url().URL)(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = undefined;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), (0, _url().fileURLToPath)(base));
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base));
  }
  var filePath;
  try {
    filePath = (0, _url().fileURLToPath)(resolved);
  } catch (error) {
    var cause = error;
    Object.defineProperty(cause, 'input', {
      value: String(resolved)
    });
    Object.defineProperty(cause, 'module', {
      value: String(base)
    });
    throw cause;
  }
  var stats = tryStatSync(filePath.endsWith('/') ? filePath.slice(-1) : filePath);
  if (stats && stats.isDirectory()) {
    var error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, _url().fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    var _error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && (0, _url().fileURLToPath)(base), true);
    _error.url = String(resolved);
    throw _error;
  }
  if (!preserveSymlinks) {
    var real = (0, _fs().realpathSync)(filePath);
    var _resolved = resolved,
      search = _resolved.search,
      hash = _resolved.hash;
    resolved = (0, _url().pathToFileURL)(real + (filePath.endsWith(_path().sep) ? '/' : ''));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), (0, _url().fileURLToPath)(base));
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  var reason = "request is not a valid match in pattern \"".concat(match, "\" for the \"").concat(internal ? 'imports' : 'exports', "\" resolution of ").concat((0, _url().fileURLToPath)(packageJsonUrl));
  throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && (0, _url().fileURLToPath)(base));
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = _typeof(target) === 'object' && target !== null ? JSON.stringify(target, null, '') : "".concat(target);
  return new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== '' && !pattern && target[target.length - 1] !== '/') throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith('./')) {
    if (internal && !target.startsWith('../') && !target.startsWith('/')) {
      var _isURL = false;
      try {
        new (_url().URL)(target);
        _isURL = true;
      } catch (_unused3) {}
      if (!_isURL) {
        var exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, function () {
          return subpath;
        }) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        var request = pattern ? match.replace('*', function () {
          return subpath;
        }) : match + subpath;
        var resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, function () {
          return subpath;
        }) : target;
        emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, true);
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  var resolved = new (_url().URL)(target, packageJsonUrl);
  var resolvedPath = resolved.pathname;
  var packagePath = new (_url().URL)('.', packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === '') return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    var _request = pattern ? match.replace('*', function () {
      return subpath;
    }) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        var _resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, function () {
          return subpath;
        }) : target;
        emitInvalidSegmentDeprecation(_resolvedTarget, _request, match, packageJsonUrl, internal, base, false);
      }
    } else {
      throwInvalidSubpath(_request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new (_url().URL)(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, function () {
      return subpath;
    }));
  }
  return new (_url().URL)(subpath, resolved);
}
function isArrayIndex(key) {
  var keyNumber = Number(key);
  if ("".concat(keyNumber) !== key) return false;
  return keyNumber >= 0 && keyNumber < 0xffffffff;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === 'string') {
    return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
  }
  if (Array.isArray(target)) {
    var targetList = target;
    if (targetList.length === 0) return null;
    var lastException;
    var i = -1;
    while (++i < targetList.length) {
      var targetItem = targetList[i];
      var resolveResult = void 0;
      try {
        resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
      } catch (error) {
        var exception = error;
        lastException = exception;
        if (exception.code === 'ERR_INVALID_PACKAGE_TARGET') continue;
        throw error;
      }
      if (resolveResult === undefined) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === undefined || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (_typeof(target) === 'object' && target !== null) {
    var keys = Object.getOwnPropertyNames(target);
    var _i2 = -1;
    while (++_i2 < keys.length) {
      var key = keys[_i2];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
      }
    }
    _i2 = -1;
    while (++_i2 < keys.length) {
      var _key2 = keys[_i2];
      if (_key2 === 'default' || conditions && conditions.has(_key2)) {
        var conditionalTarget = target[_key2];
        var _resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
        if (_resolveResult === undefined) continue;
        return _resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === 'string' || Array.isArray(exports)) return true;
  if (_typeof(exports) !== 'object' || exports === null) return false;
  var keys = Object.getOwnPropertyNames(exports);
  var isConditionalSugar = false;
  var i = 0;
  var keyIndex = -1;
  while (++keyIndex < keys.length) {
    var key = keys[keyIndex];
    var currentIsConditionalSugar = key === '' || key[0] !== '.';
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain some keys starting with \'.\' and some not.' + ' The exports object must either be an object of package subpath keys' + ' or an object of main entry condition name keys only.');
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (_process().noDeprecation) {
    return;
  }
  var pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;
  emittedPackageWarnings.add(pjsonPath + '|' + match);
  _process().emitWarning("Use of deprecated trailing slash pattern mapping \"".concat(match, "\" in the ") + "\"exports\" field module resolution of the package at ".concat(pjsonPath).concat(base ? " imported from ".concat((0, _url().fileURLToPath)(base)) : '', ". Mapping specifiers ending in \"/\" is no longer supported."), 'DeprecationWarning', 'DEP0155');
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  var exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = {
      '.': exports
    };
  }
  if (own.call(exports, packageSubpath) && !packageSubpath.includes('*') && !packageSubpath.endsWith('/')) {
    var target = exports[packageSubpath];
    var resolveResult = resolvePackageTarget(packageJsonUrl, target, '', packageSubpath, base, false, false, false, conditions);
    if (resolveResult === null || resolveResult === undefined) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  var bestMatch = '';
  var bestMatchSubpath = '';
  var keys = Object.getOwnPropertyNames(exports);
  var i = -1;
  while (++i < keys.length) {
    var key = keys[i];
    var patternIndex = key.indexOf('*');
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith('/')) {
        emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
      }
      var patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf('*') === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
      }
    }
  }
  if (bestMatch) {
    var _target = exports[bestMatch];
    var _resolveResult2 = resolvePackageTarget(packageJsonUrl, _target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith('/'), conditions);
    if (_resolveResult2 === null || _resolveResult2 === undefined) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return _resolveResult2;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  var aPatternIndex = a.indexOf('*');
  var bPatternIndex = b.indexOf('*');
  var baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  var baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === '#' || name.startsWith('#/') || name.endsWith('/')) {
    var reason = 'is not a valid internal imports specifier name';
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));
  }
  var packageJsonUrl;
  var packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    var imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name) && !name.includes('*')) {
        var resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], '', name, base, false, true, false, conditions);
        if (resolveResult !== null && resolveResult !== undefined) {
          return resolveResult;
        }
      } else {
        var bestMatch = '';
        var bestMatchSubpath = '';
        var keys = Object.getOwnPropertyNames(imports);
        var i = -1;
        while (++i < keys.length) {
          var key = keys[i];
          var patternIndex = key.indexOf('*');
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            var patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf('*') === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
            }
          }
        }
        if (bestMatch) {
          var target = imports[bestMatch];
          var _resolveResult3 = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
          if (_resolveResult3 !== null && _resolveResult3 !== undefined) {
            return _resolveResult3;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  var separatorIndex = specifier.indexOf('/');
  var validPackageName = true;
  var isScoped = false;
  if (specifier[0] === '@') {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf('/', separatorIndex + 1);
    }
  }
  var packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', (0, _url().fileURLToPath)(base));
  }
  var packageSubpath = '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));
  return {
    packageName: packageName,
    packageSubpath: packageSubpath,
    isScoped: isScoped
  };
}
function packageResolve(specifier, base, conditions) {
  if (_module().builtinModules.includes(specifier)) {
    return new (_url().URL)('node:' + specifier);
  }
  var _parsePackageName = parsePackageName(specifier, base),
    packageName = _parsePackageName.packageName,
    packageSubpath = _parsePackageName.packageSubpath,
    isScoped = _parsePackageName.isScoped;
  var packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    var _packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
      return packageExportsResolve(_packageJsonUrl, packageSubpath, packageConfig, base, conditions);
    }
  }
  var packageJsonUrl = new (_url().URL)('./node_modules/' + packageName + '/package.json', base);
  var packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  var lastPath;
  do {
    var stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat || !stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new (_url().URL)((isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json', packageJsonUrl);
      packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
      continue;
    }
    var _packageConfig = read(packageJsonPath, {
      base: base,
      specifier: specifier
    });
    if (_packageConfig.exports !== undefined && _packageConfig.exports !== null) {
      return packageExportsResolve(packageJsonUrl, packageSubpath, _packageConfig, base, conditions);
    }
    if (packageSubpath === '.') {
      return legacyMainResolve(packageJsonUrl, _packageConfig, base);
    }
    return new (_url().URL)(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === '.') {
    if (specifier.length === 1 || specifier[1] === '/') return true;
    if (specifier[1] === '.' && (specifier.length === 2 || specifier[2] === '/')) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === '') return false;
  if (specifier[0] === '/') return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  var protocol = base.protocol;
  var isData = protocol === 'data:';
  var isRemote = isData || protocol === 'http:' || protocol === 'https:';
  var resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new (_url().URL)(specifier, base);
    } catch (error_) {
      var error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === 'file:' && specifier[0] === '#') {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new (_url().URL)(specifier);
    } catch (error_) {
      if (isRemote && !_module().builtinModules.includes(specifier)) {
        var _error2 = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        _error2.cause = error_;
        throw _error2;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  _assert()(resolved !== undefined, 'expected to be defined');
  if (resolved.protocol !== 'file:') {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    var parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === 'http:' || parentProtocol === 'https:') {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        var parsedProtocol = parsed == null ? void 0 : parsed.protocol;
        if (parsedProtocol && parsedProtocol !== 'https:' && parsedProtocol !== 'http:') {
          throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, 'remote imports cannot import from a local location.');
        }
        return {
          url: (parsed == null ? void 0 : parsed.href) || ''
        };
      }
      if (_module().builtinModules.includes(specifier)) {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, 'remote imports cannot import from a local location.');
      }
      throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, 'only relative and absolute specifiers are supported.');
    }
  }
}
function isURL(self) {
  return Boolean(self && _typeof(self) === 'object' && 'href' in self && typeof self.href === 'string' && 'protocol' in self && typeof self.protocol === 'string' && self.href && self.protocol);
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL === undefined) {
    return;
  }
  if (typeof parentURL !== 'string' && !isURL(parentURL)) {
    throw new codes.ERR_INVALID_ARG_TYPE('parentURL', ['string', 'URL'], parentURL);
  }
}
function defaultResolve(specifier) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parentURL = context.parentURL;
  _assert()(parentURL !== undefined, 'expected `parentURL` to be defined');
  throwIfInvalidParentURL(parentURL);
  var parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new (_url().URL)(parentURL);
    } catch (_unused4) {}
  }
  var parsed;
  var protocol;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new (_url().URL)(specifier, parsedParentURL) : new (_url().URL)(specifier);
    protocol = parsed.protocol;
    if (protocol === 'data:') {
      return {
        url: parsed.href,
        format: null
      };
    }
  } catch (_unused5) {}
  var maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
  if (maybeReturn) return maybeReturn;
  if (protocol === undefined && parsed) {
    protocol = parsed.protocol;
  }
  if (protocol === 'node:') {
    return {
      url: specifier
    };
  }
  if (parsed && parsed.protocol === 'node:') return {
    url: specifier
  };
  var conditions = getConditionsSet(context.conditions);
  var url = moduleResolve(specifier, new (_url().URL)(parentURL), conditions, false);
  return {
    url: url.href,
    format: defaultGetFormatWithoutErrors(url, {
      parentURL: parentURL
    })
  };
}
function resolve(specifier, parent) {
  if (!parent) {
    throw new Error('Please pass `parent`: `import-meta-resolve` cannot ponyfill that');
  }
  try {
    return defaultResolve(specifier, {
      parentURL: parent
    }).url;
  } catch (error) {
    var exception = error;
    if ((exception.code === 'ERR_UNSUPPORTED_DIR_IMPORT' || exception.code === 'ERR_MODULE_NOT_FOUND') && typeof exception.url === 'string') {
      return exception.url;
    }
    throw error;
  }
}
0 && 0;