"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validatePluginObject = validatePluginObject;
var _optionAssertions = require("./option-assertions.js");
var VALIDATORS = {
  name: _optionAssertions.assertString,
  manipulateOptions: _optionAssertions.assertFunction,
  pre: _optionAssertions.assertFunction,
  post: _optionAssertions.assertFunction,
  inherits: _optionAssertions.assertFunction,
  visitor: assertVisitorMap,
  parserOverride: _optionAssertions.assertFunction,
  generatorOverride: _optionAssertions.assertFunction
};
function assertVisitorMap(loc, value) {
  var obj = (0, _optionAssertions.assertObject)(loc, value);
  if (obj) {
    Object.keys(obj).forEach(function (prop) {
      if (prop !== "_exploded" && prop !== "_verified") {
        assertVisitorHandler(prop, obj[prop]);
      }
    });
    if (obj.enter || obj.exit) {
      throw new Error("".concat((0, _optionAssertions.msg)(loc), " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes."));
    }
  }
  return obj;
}
function assertVisitorHandler(key, value) {
  if (value && _typeof(value) === "object") {
    Object.keys(value).forEach(function (handler) {
      if (handler !== "enter" && handler !== "exit") {
        throw new Error(".visitor[\"".concat(key, "\"] may only have .enter and/or .exit handlers."));
      }
    });
  } else if (typeof value !== "function") {
    throw new Error(".visitor[\"".concat(key, "\"] must be a function"));
  }
}
function validatePluginObject(obj) {
  var rootPath = {
    type: "root",
    source: "plugin"
  };
  Object.keys(obj).forEach(function (key) {
    var validator = VALIDATORS[key];
    if (validator) {
      var optLoc = {
        type: "option",
        name: key,
        parent: rootPath
      };
      validator(optLoc, obj[key]);
    } else {
      var invalidPluginPropertyError = new Error(".".concat(key, " is not a valid Plugin property"));
      invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
      throw invalidPluginPropertyError;
    }
  });
  return obj;
}
0 && 0;