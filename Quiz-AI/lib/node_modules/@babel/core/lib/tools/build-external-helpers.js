"use strict";

var _templateObject;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
function helpers() {
  var data = require("@babel/helpers");
  helpers = function helpers() {
    return data;
  };
  return data;
}
function _generator() {
  var data = require("@babel/generator");
  _generator = function _generator() {
    return data;
  };
  return data;
}
function _template() {
  var data = require("@babel/template");
  _template = function _template() {
    return data;
  };
  return data;
}
function _t() {
  var data = require("@babel/types");
  _t = function _t() {
    return data;
  };
  return data;
}
var _t2 = _t(),
  arrayExpression = _t2.arrayExpression,
  assignmentExpression = _t2.assignmentExpression,
  binaryExpression = _t2.binaryExpression,
  blockStatement = _t2.blockStatement,
  callExpression = _t2.callExpression,
  cloneNode = _t2.cloneNode,
  conditionalExpression = _t2.conditionalExpression,
  exportNamedDeclaration = _t2.exportNamedDeclaration,
  exportSpecifier = _t2.exportSpecifier,
  expressionStatement = _t2.expressionStatement,
  functionExpression = _t2.functionExpression,
  identifier = _t2.identifier,
  memberExpression = _t2.memberExpression,
  objectExpression = _t2.objectExpression,
  program = _t2.program,
  stringLiteral = _t2.stringLiteral,
  unaryExpression = _t2.unaryExpression,
  variableDeclaration = _t2.variableDeclaration,
  variableDeclarator = _t2.variableDeclarator;
var buildUmdWrapper = function buildUmdWrapper(replacements) {
  return _template()["default"].statement(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "])))(replacements);
};
function buildGlobal(allowlist) {
  var namespace = identifier("babelHelpers");
  var body = [];
  var container = functionExpression(null, [identifier("global")], blockStatement(body));
  var tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
  body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))]));
  buildHelpers(body, namespace, allowlist);
  return tree;
}
function buildModule(allowlist) {
  var body = [];
  var refs = buildHelpers(body, null, allowlist);
  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(function (name) {
    return exportSpecifier(cloneNode(refs[name]), identifier(name));
  })));
  return program(body, [], "module");
}
function buildUmd(allowlist) {
  var namespace = identifier("babelHelpers");
  var body = [];
  body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))]));
  buildHelpers(body, namespace, allowlist);
  return program([buildUmdWrapper({
    FACTORY_PARAMETERS: identifier("global"),
    BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
    COMMON_ARGUMENTS: identifier("exports"),
    AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
    FACTORY_BODY: body,
    UMD_ROOT: identifier("this")
  })]);
}
function buildVar(allowlist) {
  var namespace = identifier("babelHelpers");
  var body = [];
  body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
  var tree = program(body);
  buildHelpers(body, namespace, allowlist);
  body.push(expressionStatement(namespace));
  return tree;
}
function buildHelpers(body, namespace, allowlist) {
  var getHelperReference = function getHelperReference(name) {
    return namespace ? memberExpression(namespace, identifier(name)) : identifier("_".concat(name));
  };
  var refs = {};
  helpers().list.forEach(function (name) {
    if (allowlist && allowlist.indexOf(name) < 0) return;
    var ref = refs[name] = getHelperReference(name);
    var _helpers$get = helpers().get(name, getHelperReference, namespace ? null : "_".concat(name), [], namespace ? function (ast, exportName, mapExportBindingAssignments) {
        mapExportBindingAssignments(function (node) {
          return assignmentExpression("=", ref, node);
        });
        ast.body.push(expressionStatement(assignmentExpression("=", ref, identifier(exportName))));
      } : null),
      nodes = _helpers$get.nodes;
    body.push.apply(body, _toConsumableArray(nodes));
  });
  return refs;
}
function _default(allowlist) {
  var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "global";
  var tree;
  var build = {
    global: buildGlobal,
    module: buildModule,
    umd: buildUmd,
    "var": buildVar
  }[outputType];
  if (build) {
    tree = build(allowlist);
  } else {
    throw new Error("Unsupported output type ".concat(outputType));
  }
  return (0, _generator()["default"])(tree).code;
}
0 && 0;