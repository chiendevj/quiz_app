"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginHiddenCallStack = beginHiddenCallStack;
exports.endHiddenCallStack = endHiddenCallStack;
exports.expectedError = expectedError;
exports.injectVirtualStackFrame = injectVirtualStackFrame;
var _Object$getOwnPropert;
var ErrorToString = Function.call.bind(Error.prototype.toString);
var SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : _Object$getOwnPropert.writable) === true;
var START_HIDING = "startHiding - secret - don't use this - v1";
var STOP_HIDING = "stopHiding - secret - don't use this - v1";
var expectedErrors = new WeakSet();
var virtualFrames = new WeakMap();
function CallSite(filename) {
  return Object.create({
    isNative: function isNative() {
      return false;
    },
    isConstructor: function isConstructor() {
      return false;
    },
    isToplevel: function isToplevel() {
      return true;
    },
    getFileName: function getFileName() {
      return filename;
    },
    getLineNumber: function getLineNumber() {
      return undefined;
    },
    getColumnNumber: function getColumnNumber() {
      return undefined;
    },
    getFunctionName: function getFunctionName() {
      return undefined;
    },
    getMethodName: function getMethodName() {
      return undefined;
    },
    getTypeName: function getTypeName() {
      return undefined;
    },
    toString: function toString() {
      return filename;
    }
  });
}
function injectVirtualStackFrame(error, filename) {
  if (!SUPPORTED) return;
  var frames = virtualFrames.get(error);
  if (!frames) virtualFrames.set(error, frames = []);
  frames.push(CallSite(filename));
  return error;
}
function expectedError(error) {
  if (!SUPPORTED) return;
  expectedErrors.add(error);
  return error;
}
function beginHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function () {
    setupPrepareStackTrace();
    return fn.apply(void 0, arguments);
  }, "name", {
    value: STOP_HIDING
  });
}
function endHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function () {
    return fn.apply(void 0, arguments);
  }, "name", {
    value: START_HIDING
  });
}
function setupPrepareStackTrace() {
  setupPrepareStackTrace = function setupPrepareStackTrace() {};
  var _Error$prepareStackTr = Error.prepareStackTrace,
    prepareStackTrace = _Error$prepareStackTr === void 0 ? defaultPrepareStackTrace : _Error$prepareStackTr;
  var MIN_STACK_TRACE_LIMIT = 50;
  Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));
  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {
    var newTrace = [];
    var isExpected = expectedErrors.has(err);
    var status = isExpected ? "hiding" : "unknown";
    for (var i = 0; i < trace.length; i++) {
      var name = trace[i].getFunctionName();
      if (name === START_HIDING) {
        status = "hiding";
      } else if (name === STOP_HIDING) {
        if (status === "hiding") {
          status = "showing";
          if (virtualFrames.has(err)) {
            var _newTrace;
            (_newTrace = newTrace).unshift.apply(_newTrace, _toConsumableArray(virtualFrames.get(err)));
          }
        } else if (status === "unknown") {
          newTrace = trace;
          break;
        }
      } else if (status !== "hiding") {
        newTrace.push(trace[i]);
      }
    }
    return prepareStackTrace(err, newTrace);
  };
}
function defaultPrepareStackTrace(err, trace) {
  if (trace.length === 0) return ErrorToString(err);
  return "".concat(ErrorToString(err), "\n    at ").concat(trace.join("\n    at "));
}
0 && 0;