"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
var babelP = Promise.resolve().then(function () {
  return _interopRequireWildcard(require("./lib/index.js"));
});
var babel = null;
Object.defineProperty(exports, "__ initialize @babel/core cjs proxy __", {
  set: function set(val) {
    babel = val;
  }
});
exports.version = require("./package.json").version;
var functionNames = ["createConfigItem", "loadPartialConfig", "loadOptions", "transform", "transformFile", "transformFromAst", "parse"];
var propertyNames = ["buildExternalHelpers", "types", "tokTypes", "traverse", "template"];
var _loop = function _loop() {
  var name = _functionNames[_i];
  exports[name] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    babelP.then(function (babel) {
      babel[name].apply(babel, args);
    });
  };
  exports["".concat(name, "Async")] = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return babelP.then(function (babel) {
      return babel["".concat(name, "Async")].apply(babel, args);
    });
  };
  exports["".concat(name, "Sync")] = function () {
    var _babel;
    if (!babel) throw notLoadedError("".concat(name, "Sync"), "callable");
    return (_babel = babel)["".concat(name, "Sync")].apply(_babel, arguments);
  };
};
for (var _i = 0, _functionNames = functionNames; _i < _functionNames.length; _i++) {
  _loop();
}
var _loop2 = function _loop2() {
  var name = _propertyNames[_i2];
  Object.defineProperty(exports, name, {
    get: function get() {
      if (!babel) throw notLoadedError(name, "accessible");
      return babel[name];
    }
  });
};
for (var _i2 = 0, _propertyNames = propertyNames; _i2 < _propertyNames.length; _i2++) {
  _loop2();
}
function notLoadedError(name, keyword) {
  return new Error("The `".concat(name, "` export of @babel/core is only ").concat(keyword) + " from the CommonJS version after that the ESM version is loaded.");
}