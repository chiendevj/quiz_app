"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _assert = require("assert");
var _t = require("@babel/types");
var _importBuilder = require("./import-builder.js");
var _isModule = require("./is-module.js");
var identifier = _t.identifier,
  importSpecifier = _t.importSpecifier,
  numericLiteral = _t.numericLiteral,
  sequenceExpression = _t.sequenceExpression,
  isImportDeclaration = _t.isImportDeclaration;
var ImportInjector = /*#__PURE__*/function () {
  function ImportInjector(path, importedSource, opts) {
    _classCallCheck(this, ImportInjector);
    this._defaultOpts = {
      importedSource: null,
      importedType: "commonjs",
      importedInterop: "babel",
      importingInterop: "babel",
      ensureLiveReference: false,
      ensureNoContext: false,
      importPosition: "before"
    };
    var programPath = path.find(function (p) {
      return p.isProgram();
    });
    this._programPath = programPath;
    this._programScope = programPath.scope;
    this._hub = programPath.hub;
    this._defaultOpts = this._applyDefaults(importedSource, opts, true);
  }
  return _createClass(ImportInjector, [{
    key: "addDefault",
    value: function addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    }
  }, {
    key: "addNamed",
    value: function addNamed(importName, importedSourceIn, opts) {
      _assert(typeof importName === "string");
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    }
  }, {
    key: "addNamespace",
    value: function addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    }
  }, {
    key: "addSideEffect",
    value: function addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
    }
  }, {
    key: "_applyDefaults",
    value: function _applyDefaults(importedSource, opts) {
      var isInit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var newOpts;
      if (typeof importedSource === "string") {
        newOpts = Object.assign({}, this._defaultOpts, {
          importedSource: importedSource
        }, opts);
      } else {
        _assert(!opts, "Unexpected secondary arguments.");
        newOpts = Object.assign({}, this._defaultOpts, importedSource);
      }
      if (!isInit && opts) {
        if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
        if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
      }
      return newOpts;
    }
  }, {
    key: "_generateImport",
    value: function _generateImport(opts, importName) {
      var isDefault = importName === "default";
      var isNamed = !!importName && !isDefault;
      var isNamespace = importName === null;
      var importedSource = opts.importedSource,
        importedType = opts.importedType,
        importedInterop = opts.importedInterop,
        importingInterop = opts.importingInterop,
        ensureLiveReference = opts.ensureLiveReference,
        ensureNoContext = opts.ensureNoContext,
        nameHint = opts.nameHint,
        importPosition = opts.importPosition,
        blockHoist = opts.blockHoist;
      var name = nameHint || importName;
      var isMod = (0, _isModule["default"])(this._programPath);
      var isModuleForNode = isMod && importingInterop === "node";
      var isModuleForBabel = isMod && importingInterop === "babel";
      if (importPosition === "after" && !isMod) {
        throw new Error("\"importPosition\": \"after\" is only supported in modules");
      }
      var builder = new _importBuilder["default"](importedSource, this._programScope, this._hub);
      if (importedType === "es6") {
        if (!isModuleForNode && !isModuleForBabel) {
          throw new Error("Cannot import an ES6 module from CommonJS");
        }
        builder["import"]();
        if (isNamespace) {
          builder.namespace(nameHint || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else if (importedType !== "commonjs") {
        throw new Error("Unexpected interopType \"".concat(importedType, "\""));
      } else if (importedInterop === "babel") {
        if (isModuleForNode) {
          name = name !== "default" ? name : importedSource;
          var es6Default = "".concat(importedSource, "$es6Default");
          builder["import"]();
          if (isNamespace) {
            builder["default"](es6Default)["var"](name || importedSource).wildcardInterop();
          } else if (isDefault) {
            if (ensureLiveReference) {
              builder["default"](es6Default)["var"](name || importedSource).defaultInterop().read("default");
            } else {
              builder["default"](es6Default)["var"](name).defaultInterop().prop(importName);
            }
          } else if (isNamed) {
            builder["default"](es6Default).read(importName);
          }
        } else if (isModuleForBabel) {
          builder["import"]();
          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();
          if (isNamespace) {
            builder["var"](name || importedSource).wildcardInterop();
          } else if ((isDefault || isNamed) && ensureLiveReference) {
            if (isDefault) {
              name = name !== "default" ? name : importedSource;
              builder["var"](name).read(importName);
              builder.defaultInterop();
            } else {
              builder["var"](importedSource).read(importName);
            }
          } else if (isDefault) {
            builder["var"](name).defaultInterop().prop(importName);
          } else if (isNamed) {
            builder["var"](name).prop(importName);
          }
        }
      } else if (importedInterop === "compiled") {
        if (isModuleForNode) {
          builder["import"]();
          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault || isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();
          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();
          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault || isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder.prop(importName)["var"](name);
            }
          }
        }
      } else if (importedInterop === "uncompiled") {
        if (isDefault && ensureLiveReference) {
          throw new Error("No live reference for commonjs default");
        }
        if (isModuleForNode) {
          builder["import"]();
          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();
          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();
          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault) {
            builder["var"](name);
          } else if (isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder["var"](name).prop(importName);
            }
          }
        }
      } else {
        throw new Error("Unknown importedInterop \"".concat(importedInterop, "\"."));
      }
      var _builder$done = builder.done(),
        statements = _builder$done.statements,
        resultName = _builder$done.resultName;
      this._insertStatements(statements, importPosition, blockHoist);
      if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
        return sequenceExpression([numericLiteral(0), resultName]);
      }
      return resultName;
    }
  }, {
    key: "_insertStatements",
    value: function _insertStatements(statements) {
      var importPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "before";
      var blockHoist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
      if (importPosition === "after") {
        if (this._insertStatementsAfter(statements)) return;
      } else {
        if (this._insertStatementsBefore(statements, blockHoist)) return;
      }
      this._programPath.unshiftContainer("body", statements);
    }
  }, {
    key: "_insertStatementsBefore",
    value: function _insertStatementsBefore(statements, blockHoist) {
      if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {
        var firstImportDecl = this._programPath.get("body").find(function (p) {
          return p.isImportDeclaration() && isValueImport(p.node);
        });
        if ((firstImportDecl == null ? void 0 : firstImportDecl.node.source.value) === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])) {
          return true;
        }
      }
      statements.forEach(function (node) {
        node._blockHoist = blockHoist;
      });
      var targetPath = this._programPath.get("body").find(function (p) {
        var val = p.node._blockHoist;
        return Number.isFinite(val) && val < 4;
      });
      if (targetPath) {
        targetPath.insertBefore(statements);
        return true;
      }
      return false;
    }
  }, {
    key: "_insertStatementsAfter",
    value: function _insertStatementsAfter(statements) {
      var statementsSet = new Set(statements);
      var importDeclarations = new Map();
      var _iterator = _createForOfIteratorHelper(statements),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var statement = _step.value;
          if (isImportDeclaration(statement) && isValueImport(statement)) {
            var source = statement.source.value;
            if (!importDeclarations.has(source)) importDeclarations.set(source, []);
            importDeclarations.get(source).push(statement);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var lastImportPath = null;
      var _iterator2 = _createForOfIteratorHelper(this._programPath.get("body")),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var bodyStmt = _step2.value;
          if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {
            lastImportPath = bodyStmt;
            var _source = bodyStmt.node.source.value;
            var newImports = importDeclarations.get(_source);
            if (!newImports) continue;
            var _iterator3 = _createForOfIteratorHelper(newImports),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var decl = _step3.value;
                if (!statementsSet.has(decl)) continue;
                if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {
                  statementsSet["delete"](decl);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (statementsSet.size === 0) return true;
      if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));
      return !!lastImportPath;
    }
  }]);
}();
exports["default"] = ImportInjector;
function isValueImport(node) {
  return node.importKind !== "type" && node.importKind !== "typeof";
}
function hasNamespaceImport(node) {
  return node.specifiers.length === 1 && node.specifiers[0].type === "ImportNamespaceSpecifier" || node.specifiers.length === 2 && node.specifiers[1].type === "ImportNamespaceSpecifier";
}
function hasDefaultImport(node) {
  return node.specifiers.length > 0 && node.specifiers[0].type === "ImportDefaultSpecifier";
}
function maybeAppendImportSpecifiers(target, source) {
  var _target$specifiers;
  if (!target.specifiers.length) {
    target.specifiers = source.specifiers;
    return true;
  }
  if (!source.specifiers.length) return true;
  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;
  if (hasDefaultImport(source)) {
    if (hasDefaultImport(target)) {
      source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier("default"));
    } else {
      target.specifiers.unshift(source.specifiers.shift());
    }
  }
  (_target$specifiers = target.specifiers).push.apply(_target$specifiers, _toConsumableArray(source.specifiers));
  return true;
}