"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _templateObject, _templateObject2;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _helperEnvironmentVisitor = require("@babel/helper-environment-visitor");
var _helperMemberExpressionToFunctions = require("@babel/helper-member-expression-to-functions");
var _helperOptimiseCallExpression = require("@babel/helper-optimise-call-expression");
var _core = require("@babel/core");
var _core$types = _core.types,
  assignmentExpression = _core$types.assignmentExpression,
  booleanLiteral = _core$types.booleanLiteral,
  callExpression = _core$types.callExpression,
  cloneNode = _core$types.cloneNode,
  identifier = _core$types.identifier,
  memberExpression = _core$types.memberExpression,
  sequenceExpression = _core$types.sequenceExpression,
  stringLiteral = _core$types.stringLiteral,
  thisExpression = _core$types.thisExpression;
{
  var ns = require("@babel/helper-environment-visitor");
  exports.environmentVisitor = ns["default"];
  exports.skipAllButComputedKey = ns.skipAllButComputedKey;
}
function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
  objectRef = cloneNode(objectRef);
  var targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
  return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
}
var visitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor["default"], {
  Super: function Super(path, state) {
    var node = path.node,
      parentPath = path.parentPath;
    if (!parentPath.isMemberExpression({
      object: node
    })) return;
    state.handle(parentPath);
  }
}]);
var unshadowSuperBindingVisitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor["default"], {
  Scopable: function Scopable(path, _ref) {
    var refName = _ref.refName;
    var binding = path.scope.getOwnBinding(refName);
    if (binding && binding.identifier.name === refName) {
      path.scope.rename(refName);
    }
  }
}]);
var specHandlers = {
  memoise: function memoise(superMember, count) {
    var scope = superMember.scope,
      node = superMember.node;
    var computed = node.computed,
      property = node.property;
    if (!computed) {
      return;
    }
    var memo = scope.maybeGenerateMemoised(property);
    if (!memo) {
      return;
    }
    this.memoiser.set(property, memo, count);
  },
  prop: function prop(superMember) {
    var _superMember$node = superMember.node,
      computed = _superMember$node.computed,
      property = _superMember$node.property;
    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }
    if (computed) {
      return cloneNode(property);
    }
    return stringLiteral(property.name);
  },
  get: function get(superMember) {
    return this._get(superMember, this._getThisRefs());
  },
  _get: function _get(superMember, thisRefs) {
    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression(this.file.addHelper("get"), [thisRefs.needAccessFirst ? sequenceExpression([thisRefs["this"], proto]) : proto, this.prop(superMember), thisRefs["this"]]);
  },
  _getThisRefs: function _getThisRefs() {
    return {
      needAccessFirst: this.isDerivedConstructor,
      "this": thisExpression()
    };
  },
  set: function set(superMember, value) {
    var thisRefs = this._getThisRefs();
    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression(this.file.addHelper("set"), [thisRefs.needAccessFirst ? sequenceExpression([thisRefs["this"], proto]) : proto, this.prop(superMember), value, thisRefs["this"], booleanLiteral(superMember.isInStrictMode())]);
  },
  destructureSet: function destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call: function call(superMember, args) {
    var thisRefs = this._getThisRefs();
    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    var thisRefs = this._getThisRefs();
    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, true);
  },
  "delete": function _delete(superMember) {
    if (superMember.node.computed) {
      return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        "])))]);
    } else {
      return _core.template.expression.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      "])));
    }
  }
};
var looseHandlers = Object.assign({}, specHandlers, {
  prop: function prop(superMember) {
    var property = superMember.node.property;
    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }
    return cloneNode(property);
  },
  get: function get(superMember) {
    var isStatic = this.isStatic,
      getSuperRef = this.getSuperRef;
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    var object;
    if (isStatic) {
      var _getSuperRef;
      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
    } else {
      var _getSuperRef2;
      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
    }
    return memberExpression(object, prop, computed);
  },
  set: function set(superMember, value) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
  },
  destructureSet: function destructureSet(superMember) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return memberExpression(thisExpression(), prop, computed);
  },
  call: function call(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), thisExpression(), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), thisExpression(), args, true);
  }
});
var ReplaceSupers = /*#__PURE__*/function () {
  function ReplaceSupers(opts) {
    _classCallCheck(this, ReplaceSupers);
    var _opts$constantSuper;
    var path = opts.methodPath;
    this.methodPath = path;
    this.isDerivedConstructor = path.isClassMethod({
      kind: "constructor"
    }) && !!opts.superRef;
    this.isStatic = path.isObjectMethod() || path.node["static"] || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
    this.isPrivateMethod = path.isPrivate() && path.isMethod();
    this.file = opts.file;
    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
    this.opts = opts;
  }
  return _createClass(ReplaceSupers, [{
    key: "getObjectRef",
    value: function getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
  }, {
    key: "getSuperRef",
    value: function getSuperRef() {
      if (this.opts.superRef) return cloneNode(this.opts.superRef);
      if (this.opts.getSuperRef) {
        return cloneNode(this.opts.getSuperRef());
      }
    }
  }, {
    key: "replace",
    value: function replace() {
      var methodPath = this.methodPath;
      if (this.opts.refToPreserve) {
        methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
      }
      var handler = this.constantSuper ? looseHandlers : specHandlers;
      visitor.shouldSkip = function (path) {
        if (path.parentPath === methodPath) {
          if (path.parentKey === "decorators" || path.parentKey === "key") {
            return true;
          }
        }
      };
      (0, _helperMemberExpressionToFunctions["default"])(methodPath, visitor, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: handler.get
      }, handler));
    }
  }]);
}();
exports["default"] = ReplaceSupers;