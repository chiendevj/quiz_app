"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = normalizeModuleAndLoadMetadata;
exports.hasExports = hasExports;
exports.isSideEffectImport = isSideEffectImport;
exports.validateImportInteropOption = validateImportInteropOption;
var _path = require("path");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _helperSplitExportDeclaration = require("@babel/helper-split-export-declaration");
function hasExports(metadata) {
  return metadata.hasExports;
}
function isSideEffectImport(source) {
  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
}
function validateImportInteropOption(importInterop) {
  if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
    throw new Error(".importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ".concat(importInterop, ")."));
  }
  return importInterop;
}
function resolveImportInterop(importInterop, source, filename) {
  if (typeof importInterop === "function") {
    return validateImportInteropOption(importInterop(source, filename));
  }
  return importInterop;
}
function normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {
  var importInterop = _ref.importInterop,
    _ref$initializeReexpo = _ref.initializeReexports,
    initializeReexports = _ref$initializeReexpo === void 0 ? false : _ref$initializeReexpo,
    getWrapperPayload = _ref.getWrapperPayload,
    _ref$esNamespaceOnly = _ref.esNamespaceOnly,
    esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly,
    filename = _ref.filename;
  if (!exportName) {
    exportName = programPath.scope.generateUidIdentifier("exports").name;
  }
  var stringSpecifiers = new Set();
  nameAnonymousExports(programPath);
  var _getModuleMetadata = getModuleMetadata(programPath, {
      initializeReexports: initializeReexports,
      getWrapperPayload: getWrapperPayload
    }, stringSpecifiers),
    local = _getModuleMetadata.local,
    sources = _getModuleMetadata.sources,
    hasExports = _getModuleMetadata.hasExports;
  removeImportExportDeclarations(programPath);
  var _iterator = _createForOfIteratorHelper(sources),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        source = _step$value[0],
        metadata = _step$value[1];
      var importsNamespace = metadata.importsNamespace,
        imports = metadata.imports;
      if (importsNamespace.size > 0 && imports.size === 0) {
        var _importsNamespace = _slicedToArray(importsNamespace, 1),
          nameOfnamespace = _importsNamespace[0];
        metadata.name = nameOfnamespace;
      }
      var resolvedInterop = resolveImportInterop(importInterop, source, filename);
      if (resolvedInterop === "none") {
        metadata.interop = "none";
      } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
        metadata.interop = "node-namespace";
      } else if (resolvedInterop === "node" && metadata.interop === "default") {
        metadata.interop = "node-default";
      } else if (esNamespaceOnly && metadata.interop === "namespace") {
        metadata.interop = "default";
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    exportName: exportName,
    exportNameListName: null,
    hasExports: hasExports,
    local: local,
    source: sources,
    stringSpecifiers: stringSpecifiers
  };
}
function getExportSpecifierName(path, stringSpecifiers) {
  if (path.isIdentifier()) {
    return path.node.name;
  } else if (path.isStringLiteral()) {
    var stringValue = path.node.value;
    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
      stringSpecifiers.add(stringValue);
    }
    return stringValue;
  } else {
    throw new Error("Expected export specifier to be either Identifier or StringLiteral, got ".concat(path.node.type));
  }
}
function assertExportSpecifier(path) {
  if (path.isExportSpecifier()) {
    return;
  } else if (path.isExportNamespaceSpecifier()) {
    throw path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
  } else {
    throw path.buildCodeFrameError("Unexpected export specifier type");
  }
}
function getModuleMetadata(programPath, _ref2, stringSpecifiers) {
  var getWrapperPayload = _ref2.getWrapperPayload,
    initializeReexports = _ref2.initializeReexports;
  var localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
  var importNodes = new Map();
  var sourceData = new Map();
  var getData = function getData(sourceNode, node) {
    var source = sourceNode.value;
    var data = sourceData.get(source);
    if (!data) {
      data = {
        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
        interop: "none",
        loc: null,
        imports: new Map(),
        importsNamespace: new Set(),
        reexports: new Map(),
        reexportNamespace: new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        },
        referenced: false
      };
      sourceData.set(source, data);
      importNodes.set(source, [node]);
    } else {
      importNodes.get(source).push(node);
    }
    return data;
  };
  var hasExports = false;
  programPath.get("body").forEach(function (child) {
    if (child.isImportDeclaration()) {
      var data = getData(child.node.source, child.node);
      if (!data.loc) data.loc = child.node.loc;
      child.get("specifiers").forEach(function (spec) {
        if (spec.isImportDefaultSpecifier()) {
          var localName = spec.get("local").node.name;
          data.imports.set(localName, "default");
          var reexport = localData.get(localName);
          if (reexport) {
            localData["delete"](localName);
            reexport.names.forEach(function (name) {
              data.reexports.set(name, "default");
            });
            data.referenced = true;
          }
        } else if (spec.isImportNamespaceSpecifier()) {
          var _localName = spec.get("local").node.name;
          data.importsNamespace.add(_localName);
          var _reexport = localData.get(_localName);
          if (_reexport) {
            localData["delete"](_localName);
            _reexport.names.forEach(function (name) {
              data.reexportNamespace.add(name);
            });
            data.referenced = true;
          }
        } else if (spec.isImportSpecifier()) {
          var importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
          var _localName2 = spec.get("local").node.name;
          data.imports.set(_localName2, importName);
          var _reexport2 = localData.get(_localName2);
          if (_reexport2) {
            localData["delete"](_localName2);
            _reexport2.names.forEach(function (name) {
              data.reexports.set(name, importName);
            });
            data.referenced = true;
          }
        }
      });
    } else if (child.isExportAllDeclaration()) {
      hasExports = true;
      var _data = getData(child.node.source, child.node);
      if (!_data.loc) _data.loc = child.node.loc;
      _data.reexportAll = {
        loc: child.node.loc
      };
      _data.referenced = true;
    } else if (child.isExportNamedDeclaration() && child.node.source) {
      hasExports = true;
      var _data2 = getData(child.node.source, child.node);
      if (!_data2.loc) _data2.loc = child.node.loc;
      child.get("specifiers").forEach(function (spec) {
        assertExportSpecifier(spec);
        var importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
        var exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
        _data2.reexports.set(exportName, importName);
        _data2.referenced = true;
        if (exportName === "__esModule") {
          throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        }
      });
    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
      hasExports = true;
    }
  });
  var _iterator2 = _createForOfIteratorHelper(sourceData.values()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _metadata = _step2.value;
      var needsDefault = false;
      var needsNamed = false;
      if (_metadata.importsNamespace.size > 0) {
        needsDefault = true;
        needsNamed = true;
      }
      if (_metadata.reexportAll) {
        needsNamed = true;
      }
      var _iterator4 = _createForOfIteratorHelper(_metadata.imports.values()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var importName = _step4.value;
          if (importName === "default") needsDefault = true;else needsNamed = true;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      var _iterator5 = _createForOfIteratorHelper(_metadata.reexports.values()),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _importName = _step5.value;
          if (_importName === "default") needsDefault = true;else needsNamed = true;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (needsDefault && needsNamed) {
        _metadata.interop = "namespace";
      } else if (needsDefault) {
        _metadata.interop = "default";
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (getWrapperPayload) {
    var _iterator3 = _createForOfIteratorHelper(sourceData),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _step3$value = _slicedToArray(_step3.value, 2),
          source = _step3$value[0],
          metadata = _step3$value[1];
        metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  return {
    hasExports: hasExports,
    local: localData,
    sources: sourceData
  };
}
function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
  var bindingKindLookup = new Map();
  programPath.get("body").forEach(function (child) {
    var kind;
    if (child.isImportDeclaration()) {
      kind = "import";
    } else {
      if (child.isExportDefaultDeclaration()) {
        child = child.get("declaration");
      }
      if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child = child.get("declaration");
        } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
          child.get("specifiers").forEach(function (spec) {
            assertExportSpecifier(spec);
            bindingKindLookup.set(spec.get("local").node.name, "block");
          });
          return;
        }
      }
      if (child.isFunctionDeclaration()) {
        kind = "hoisted";
      } else if (child.isClassDeclaration()) {
        kind = "block";
      } else if (child.isVariableDeclaration({
        kind: "var"
      })) {
        kind = "var";
      } else if (child.isVariableDeclaration()) {
        kind = "block";
      } else {
        return;
      }
    }
    Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
      bindingKindLookup.set(name, kind);
    });
  });
  var localMetadata = new Map();
  var getLocalMetadata = function getLocalMetadata(idPath) {
    var localName = idPath.node.name;
    var metadata = localMetadata.get(localName);
    if (!metadata) {
      var kind = bindingKindLookup.get(localName);
      if (kind === undefined) {
        throw idPath.buildCodeFrameError("Exporting local \"".concat(localName, "\", which is not declared."));
      }
      metadata = {
        names: [],
        kind: kind
      };
      localMetadata.set(localName, metadata);
    }
    return metadata;
  };
  programPath.get("body").forEach(function (child) {
    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
      if (child.node.declaration) {
        var declaration = child.get("declaration");
        var ids = declaration.getOuterBindingIdentifierPaths();
        Object.keys(ids).forEach(function (name) {
          if (name === "__esModule") {
            throw declaration.buildCodeFrameError('Illegal export "__esModule".');
          }
          getLocalMetadata(ids[name]).names.push(name);
        });
      } else {
        child.get("specifiers").forEach(function (spec) {
          var local = spec.get("local");
          var exported = spec.get("exported");
          var localMetadata = getLocalMetadata(local);
          var exportName = getExportSpecifierName(exported, stringSpecifiers);
          if (exportName === "__esModule") {
            throw exported.buildCodeFrameError('Illegal export "__esModule".');
          }
          localMetadata.names.push(exportName);
        });
      }
    } else if (child.isExportDefaultDeclaration()) {
      var _declaration = child.get("declaration");
      if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
        getLocalMetadata(_declaration.get("id")).names.push("default");
      } else {
        throw _declaration.buildCodeFrameError("Unexpected default expression export.");
      }
    }
  });
  return localMetadata;
}
function nameAnonymousExports(programPath) {
  programPath.get("body").forEach(function (child) {
    if (!child.isExportDefaultDeclaration()) return;
    (0, _helperSplitExportDeclaration["default"])(child);
  });
}
function removeImportExportDeclarations(programPath) {
  programPath.get("body").forEach(function (child) {
    if (child.isImportDeclaration()) {
      child.remove();
    } else if (child.isExportNamedDeclaration()) {
      if (child.node.declaration) {
        child.node.declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(child.node.declaration);
      } else {
        child.remove();
      }
    } else if (child.isExportDefaultDeclaration()) {
      var declaration = child.get("declaration");
      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
        declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(declaration);
      } else {
        throw declaration.buildCodeFrameError("Unexpected default expression export.");
      }
    } else if (child.isExportAllDeclaration()) {
      child.remove();
    }
  });
}