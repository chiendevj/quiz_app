"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCompilationTargets = _interopRequireWildcard(require("@babel/helper-compilation-targets"));
var _babel = _interopRequireWildcard(require("@babel/core"));
var _excluded = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];
var _templateObject, _templateObject2, _templateObject3;
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }
var _ref2 = _babel["default"] || _babel,
  t$1 = _ref2.types,
  template = _ref2.template;
function intersection(a, b) {
  var result = new Set();
  a.forEach(function (v) {
    return b.has(v) && result.add(v);
  });
  return result;
}
function has$1(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}
function getType(target) {
  return Object.prototype.toString.call(target).slice(8, -1);
}
function resolveId(path) {
  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, /* noGlobals */true)) {
    return path.node.name;
  }
  if (path.isPure()) {
    var _path$evaluate = path.evaluate(),
      deopt = _path$evaluate.deopt;
    if (deopt && deopt.isIdentifier()) {
      return deopt.node.name;
    }
  }
}
function resolveKey(path) {
  var computed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var scope = path.scope;
  if (path.isStringLiteral()) return path.node.value;
  var isIdentifier = path.isIdentifier();
  if (isIdentifier && !(computed || path.parent.computed)) {
    return path.node.name;
  }
  if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
    name: "Symbol"
  }) && !scope.hasBinding("Symbol", /* noGlobals */true)) {
    var sym = resolveKey(path.get("property"), path.node.computed);
    if (sym) return "Symbol." + sym;
  }
  if (isIdentifier ? scope.hasBinding(path.node.name, /* noGlobals */true) : path.isPure()) {
    var _path$evaluate2 = path.evaluate(),
      value = _path$evaluate2.value;
    if (typeof value === "string") return value;
  }
}
function resolveSource(obj) {
  if (obj.isMemberExpression() && obj.get("property").isIdentifier({
    name: "prototype"
  })) {
    var _id = resolveId(obj.get("object"));
    if (_id) {
      return {
        id: _id,
        placement: "prototype"
      };
    }
    return {
      id: null,
      placement: null
    };
  }
  var id = resolveId(obj);
  if (id) {
    return {
      id: id,
      placement: "static"
    };
  }
  if (obj.isRegExpLiteral()) {
    return {
      id: "RegExp",
      placement: "prototype"
    };
  } else if (obj.isFunction()) {
    return {
      id: "Function",
      placement: "prototype"
    };
  } else if (obj.isPure()) {
    var _obj$evaluate = obj.evaluate(),
      value = _obj$evaluate.value;
    if (value !== undefined) {
      return {
        id: getType(value),
        placement: "prototype"
      };
    }
  }
  return {
    id: null,
    placement: null
  };
}
function getImportSource(_ref3) {
  var node = _ref3.node;
  if (node.specifiers.length === 0) return node.source.value;
}
function getRequireSource(_ref4) {
  var node = _ref4.node;
  if (!t$1.isExpressionStatement(node)) return;
  var expression = node.expression;
  if (t$1.isCallExpression(expression) && t$1.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t$1.isStringLiteral(expression.arguments[0])) {
    return expression.arguments[0].value;
  }
}
function hoist(node) {
  // @ts-expect-error
  node._blockHoist = 3;
  return node;
}
function createUtilsGetter(cache) {
  return function (path) {
    var prog = path.findParent(function (p) {
      return p.isProgram();
    });
    return {
      injectGlobalImport: function injectGlobalImport(url, moduleName) {
        cache.storeAnonymous(prog, url, moduleName, function (isScript, source) {
          return isScript ? template.statement.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["require(", ")"])), source) : t$1.importDeclaration([], source);
        });
      },
      injectNamedImport: function injectNamedImport(url, name) {
        var hint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : name;
        var moduleName = arguments.length > 3 ? arguments[3] : undefined;
        return cache.storeNamed(prog, url, name, moduleName, function (isScript, source, name) {
          var id = prog.scope.generateUidIdentifier(hint);
          return {
            node: isScript ? hoist(template.statement.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n                  var ", " = require(", ").", "\n                "])), id, source, name)) : t$1.importDeclaration([t$1.importSpecifier(id, name)], source),
            name: id.name
          };
        });
      },
      injectDefaultImport: function injectDefaultImport(url) {
        var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
        var moduleName = arguments.length > 2 ? arguments[2] : undefined;
        return cache.storeNamed(prog, url, "default", moduleName, function (isScript, source) {
          var id = prog.scope.generateUidIdentifier(hint);
          return {
            node: isScript ? hoist(template.statement.ast(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["var ", " = require(", ")"])), id, source)) : t$1.importDeclaration([t$1.importDefaultSpecifier(id)], source),
            name: id.name
          };
        });
      }
    };
  };
}
var _ref5 = _babel["default"] || _babel,
  t = _ref5.types;
var ImportsCachedInjector = /*#__PURE__*/function () {
  function ImportsCachedInjector(resolver, getPreferredIndex) {
    _classCallCheck(this, ImportsCachedInjector);
    this._imports = new WeakMap();
    this._anonymousImports = new WeakMap();
    this._lastImports = new WeakMap();
    this._resolver = resolver;
    this._getPreferredIndex = getPreferredIndex;
  }
  return _createClass(ImportsCachedInjector, [{
    key: "storeAnonymous",
    value: function storeAnonymous(programPath, url, moduleName, getVal) {
      var key = this._normalizeKey(programPath, url);
      var imports = this._ensure(this._anonymousImports, programPath, Set);
      if (imports.has(key)) return;
      var node = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)));
      imports.add(key);
      this._injectImport(programPath, node, moduleName);
    }
  }, {
    key: "storeNamed",
    value: function storeNamed(programPath, url, name, moduleName, getVal) {
      var key = this._normalizeKey(programPath, url, name);
      var imports = this._ensure(this._imports, programPath, Map);
      if (!imports.has(key)) {
        var _getVal = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)), t.identifier(name)),
          node = _getVal.node,
          id = _getVal.name;
        imports.set(key, id);
        this._injectImport(programPath, node, moduleName);
      }
      return t.identifier(imports.get(key));
    }
  }, {
    key: "_injectImport",
    value: function _injectImport(programPath, node, moduleName) {
      var _this$_lastImports$ge;
      var newIndex = this._getPreferredIndex(moduleName);
      var lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];
      var isPathStillValid = function isPathStillValid(path) {
        return path.node &&
        // Sometimes the AST is modified and the "last import"
        // we have has been replaced
        path.parent === programPath.node && path.container === programPath.node.body;
      };
      var last;
      if (newIndex === Infinity) {
        // Fast path: we can always just insert at the end if newIndex is `Infinity`
        if (lastImports.length > 0) {
          last = lastImports[lastImports.length - 1].path;
          if (!isPathStillValid(last)) last = undefined;
        }
      } else {
        var _iterator = _createForOfIteratorHelper(lastImports.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              i = _step$value[0],
              data = _step$value[1];
            var path = data.path,
              index = data.index;
            if (isPathStillValid(path)) {
              if (newIndex < index) {
                var _path$insertBefore = path.insertBefore(node),
                  _path$insertBefore2 = _slicedToArray(_path$insertBefore, 1),
                  newPath = _path$insertBefore2[0];
                lastImports.splice(i, 0, {
                  path: newPath,
                  index: newIndex
                });
                return;
              }
              last = path;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      if (last) {
        var _last$insertAfter = last.insertAfter(node),
          _last$insertAfter2 = _slicedToArray(_last$insertAfter, 1),
          _newPath = _last$insertAfter2[0];
        lastImports.push({
          path: _newPath,
          index: newIndex
        });
      } else {
        var _programPath$unshiftC = programPath.unshiftContainer("body", node),
          _programPath$unshiftC2 = _slicedToArray(_programPath$unshiftC, 1),
          _newPath2 = _programPath$unshiftC2[0];
        this._lastImports.set(programPath, [{
          path: _newPath2,
          index: newIndex
        }]);
      }
    }
  }, {
    key: "_ensure",
    value: function _ensure(map, programPath, Collection) {
      var collection = map.get(programPath);
      if (!collection) {
        collection = new Collection();
        map.set(programPath, collection);
      }
      return collection;
    }
  }, {
    key: "_normalizeKey",
    value: function _normalizeKey(programPath, url) {
      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      var sourceType = programPath.node.sourceType;

      // If we rely on the imported binding (the "name" parameter), we also need to cache
      // based on the sourceType. This is because the module transforms change the names
      // of the import variables.
      return "".concat(name && sourceType, "::").concat(url, "::").concat(name);
    }
  }]);
}();
var presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";
function stringifyTargetsMultiline(targets) {
  return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);
}
function patternToRegExp(pattern) {
  if (pattern instanceof RegExp) return pattern;
  try {
    return new RegExp("^".concat(pattern, "$"));
  } catch (_unused) {
    return null;
  }
}
function buildUnusedError(label, unused) {
  if (!unused.length) return "";
  return "  - The following \"".concat(label, "\" patterns didn't match any polyfill:\n") + unused.map(function (original) {
    return "    ".concat(String(original), "\n");
  }).join("");
}
function buldDuplicatesError(duplicates) {
  if (!duplicates.size) return "";
  return "  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\n" + Array.from(duplicates, function (name) {
    return "    ".concat(name, "\n");
  }).join("");
}
function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
  var current;
  var filter = function filter(pattern) {
    var regexp = patternToRegExp(pattern);
    if (!regexp) return false;
    var matched = false;
    var _iterator2 = _createForOfIteratorHelper(polyfills.keys()),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var polyfill = _step2.value;
        if (regexp.test(polyfill)) {
          matched = true;
          current.add(polyfill);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return !matched;
  };

  // prettier-ignore
  var include = current = new Set();
  var unusedInclude = Array.from(includePatterns).filter(filter);

  // prettier-ignore
  var exclude = current = new Set();
  var unusedExclude = Array.from(excludePatterns).filter(filter);
  var duplicates = intersection(include, exclude);
  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
    throw new Error("Error while validating the \"".concat(provider, "\" provider options:\n") + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + buldDuplicatesError(duplicates));
  }
  return {
    include: include,
    exclude: exclude
  };
}
function applyMissingDependenciesDefaults(options, babelApi) {
  var _options$missingDepen = options.missingDependencies,
    missingDependencies = _options$missingDepen === void 0 ? {} : _options$missingDepen;
  if (missingDependencies === false) return false;
  var caller = babelApi.caller(function (caller) {
    return caller == null ? void 0 : caller.name;
  });
  var _missingDependencies$ = missingDependencies.log,
    log = _missingDependencies$ === void 0 ? "deferred" : _missingDependencies$,
    _missingDependencies$2 = missingDependencies.inject,
    inject = _missingDependencies$2 === void 0 ? caller === "rollup-plugin-babel" ? "throw" : "import" : _missingDependencies$2,
    _missingDependencies$3 = missingDependencies.all,
    all = _missingDependencies$3 === void 0 ? false : _missingDependencies$3;
  return {
    log: log,
    inject: inject,
    all: all
  };
}
function isRemoved(path) {
  if (path.removed) return true;
  if (!path.parentPath) return false;
  if (path.listKey) {
    var _path$parentPath$node;
    if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;
  } else {
    if (path.parentPath.node[path.key] !== path.node) return true;
  }
  return isRemoved(path.parentPath);
}
var usage = function usage(callProvider) {
  function property(object, key, placement, path) {
    return callProvider({
      kind: "property",
      object: object,
      key: key,
      placement: placement
    }, path);
  }
  function handleReferencedIdentifier(path) {
    var name = path.node.name,
      scope = path.scope;
    if (scope.getBindingIdentifier(name)) return;
    callProvider({
      kind: "global",
      name: name
    }, path);
  }
  function analyzeMemberExpression(path) {
    var key = resolveKey(path.get("property"), path.node.computed);
    return {
      key: key,
      handleAsMemberExpression: !!key && key !== "prototype"
    };
  }
  return {
    // Symbol(), new Promise
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      var parentPath = path.parentPath;
      if (parentPath.isMemberExpression({
        object: path.node
      }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {
        return;
      }
      handleReferencedIdentifier(path);
    },
    MemberExpression: function MemberExpression(path) {
      var _analyzeMemberExpress = analyzeMemberExpression(path),
        key = _analyzeMemberExpress.key,
        handleAsMemberExpression = _analyzeMemberExpress.handleAsMemberExpression;
      if (!handleAsMemberExpression) return;
      var object = path.get("object");
      var objectIsGlobalIdentifier = object.isIdentifier();
      if (objectIsGlobalIdentifier) {
        var binding = object.scope.getBinding(object.node.name);
        if (binding) {
          if (binding.path.isImportNamespaceSpecifier()) return;
          objectIsGlobalIdentifier = false;
        }
      }
      var source = resolveSource(object);
      var skipObject = property(source.id, key, source.placement, path);
      skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));
      if (!skipObject) handleReferencedIdentifier(object);
    },
    ObjectPattern: function ObjectPattern(path) {
      var parentPath = path.parentPath,
        parent = path.parent;
      var obj;

      // const { keys, values } = Object
      if (parentPath.isVariableDeclarator()) {
        obj = parentPath.get("init");
        // ({ keys, values } = Object)
      } else if (parentPath.isAssignmentExpression()) {
        obj = parentPath.get("right");
        // !function ({ keys, values }) {...} (Object)
        // resolution does not work after properties transform :-(
      } else if (parentPath.isFunction()) {
        var grand = parentPath.parentPath;
        if (grand.isCallExpression() || grand.isNewExpression()) {
          if (grand.node.callee === parent) {
            obj = grand.get("arguments")[path.key];
          }
        }
      }
      var id = null;
      var placement = null;
      if (obj) {
        var _resolveSource = resolveSource(obj);
        id = _resolveSource.id;
        placement = _resolveSource.placement;
      }
      var _iterator3 = _createForOfIteratorHelper(path.get("properties")),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var prop = _step3.value;
          if (prop.isObjectProperty()) {
            var key = resolveKey(prop.get("key"));
            if (key) property(id, key, placement, prop);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    BinaryExpression: function BinaryExpression(path) {
      if (path.node.operator !== "in") return;
      var source = resolveSource(path.get("right"));
      var key = resolveKey(path.get("left"), true);
      if (!key) return;
      callProvider({
        kind: "in",
        object: source.id,
        key: key,
        placement: source.placement
      }, path);
    }
  };
};
var entry = function entry(callProvider) {
  return {
    ImportDeclaration: function ImportDeclaration(path) {
      var source = getImportSource(path);
      if (!source) return;
      callProvider({
        kind: "import",
        source: source
      }, path);
    },
    Program: function Program(path) {
      path.get("body").forEach(function (bodyPath) {
        var source = getRequireSource(bodyPath);
        if (!source) return;
        callProvider({
          kind: "import",
          source: source
        }, bodyPath);
      });
    }
  };
};
function resolve(dirname, moduleName, absoluteImports) {
  if (absoluteImports === false) return moduleName;
  throw new Error("\"absoluteImports\" is not supported in bundles prepared for the browser.");
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function has(basedir, name) {
  return true;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function logMissing(missingDeps) {}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function laterLogMissing(missingDeps) {}
var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);
function createMetaResolver(polyfills) {
  var staticP = polyfills["static"],
    instanceP = polyfills.instance,
    globalP = polyfills.global;
  return function (meta) {
    if (meta.kind === "global" && globalP && has$1(globalP, meta.name)) {
      return {
        kind: "global",
        desc: globalP[meta.name],
        name: meta.name
      };
    }
    if (meta.kind === "property" || meta.kind === "in") {
      var placement = meta.placement,
        object = meta.object,
        key = meta.key;
      if (object && placement === "static") {
        if (globalP && PossibleGlobalObjects.has(object) && has$1(globalP, key)) {
          return {
            kind: "global",
            desc: globalP[key],
            name: key
          };
        }
        if (staticP && has$1(staticP, object) && has$1(staticP[object], key)) {
          return {
            kind: "static",
            desc: staticP[object][key],
            name: "".concat(object, "$").concat(key)
          };
        }
      }
      if (instanceP && has$1(instanceP, key)) {
        return {
          kind: "instance",
          desc: instanceP[key],
          name: "".concat(key)
        };
      }
    }
  };
}
var getTargets = _helperCompilationTargets["default"]["default"] || _helperCompilationTargets["default"];
function resolveOptions(options, babelApi) {
  var method = options.method,
    targetsOption = options.targets,
    ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
    configPath = options.configPath,
    debug = options.debug,
    shouldInjectPolyfill = options.shouldInjectPolyfill,
    absoluteImports = options.absoluteImports,
    providerOptions = _objectWithoutProperties(options, _excluded);
  if (isEmpty(options)) {
    throw new Error("This plugin requires options, for example:\n    {\n      \"plugins\": [\n        [\"<plugin name>\", { method: \"usage-pure\" }]\n      ]\n    }\n\nSee more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md");
  }
  var methodName;
  if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
    throw new Error(".method must be a string");
  } else {
    throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + " or \"usage-pure\" (received ".concat(JSON.stringify(method), ")"));
  }
  if (typeof shouldInjectPolyfill === "function") {
    if (options.include || options.exclude) {
      throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
    }
  } else if (shouldInjectPolyfill != null) {
    throw new Error(".shouldInjectPolyfill must be a function, or undefined" + " (received ".concat(JSON.stringify(shouldInjectPolyfill), ")"));
  }
  if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
    throw new Error(".absoluteImports must be a boolean, a string, or undefined" + " (received ".concat(JSON.stringify(absoluteImports), ")"));
  }
  var targets;
  if (
  // If any browserslist-related option is specified, fallback to the old
  // behavior of not using the targets specified in the top-level options.
  targetsOption || configPath || ignoreBrowserslistConfig) {
    var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
      browsers: targetsOption
    } : targetsOption;
    targets = getTargets(targetsObj, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath
    });
  } else {
    targets = babelApi.targets();
  }
  return {
    method: method,
    methodName: methodName,
    targets: targets,
    absoluteImports: absoluteImports != null ? absoluteImports : false,
    shouldInjectPolyfill: shouldInjectPolyfill,
    debug: !!debug,
    providerOptions: providerOptions
  };
}
function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
  var _resolveOptions = resolveOptions(options, babelApi),
    method = _resolveOptions.method,
    methodName = _resolveOptions.methodName,
    targets = _resolveOptions.targets,
    _debug = _resolveOptions.debug,
    _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
    providerOptions = _resolveOptions.providerOptions,
    absoluteImports = _resolveOptions.absoluteImports;

  // eslint-disable-next-line prefer-const
  var include, exclude;
  var polyfillsSupport;
  var polyfillsNames;
  var filterPolyfills;
  var getUtils = createUtilsGetter(new ImportsCachedInjector(function (moduleName) {
    return resolve(dirname, moduleName, absoluteImports);
  }, function (name) {
    var _polyfillsNames$get, _polyfillsNames;
    return (_polyfillsNames$get = (_polyfillsNames = polyfillsNames) == null ? void 0 : _polyfillsNames.get(name)) != null ? _polyfillsNames$get : Infinity;
  }));
  var depsCache = new Map();
  var api = {
    babel: babelApi,
    getUtils: getUtils,
    method: options.method,
    targets: targets,
    createMetaResolver: createMetaResolver,
    shouldInjectPolyfill: function shouldInjectPolyfill(name) {
      if (polyfillsNames === undefined) {
        throw new Error("Internal error in the ".concat(factory.name, " provider: ") + "shouldInjectPolyfill() can't be called during initialization.");
      }
      if (!polyfillsNames.has(name)) {
        console.warn("Internal error in the ".concat(providerName, " provider: ") + "unknown polyfill \"".concat(name, "\"."));
      }
      if (filterPolyfills && !filterPolyfills(name)) return false;
      var shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {
        compatData: polyfillsSupport,
        includes: include,
        excludes: exclude
      });
      if (_shouldInjectPolyfill) {
        shouldInject = _shouldInjectPolyfill(name, shouldInject);
        if (typeof shouldInject !== "boolean") {
          throw new Error(".shouldInjectPolyfill must return a boolean.");
        }
      }
      return shouldInject;
    },
    debug: function debug(name) {
      var _debugLog, _debugLog$polyfillsSu;
      debugLog().found = true;
      if (!_debug || !name) return;
      if (debugLog().polyfills.has(providerName)) return;
      debugLog().polyfills.add(name);
      (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;
    },
    assertDependency: function assertDependency(name) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
      if (missingDependencies === false) return;
      if (absoluteImports) {
        // If absoluteImports is not false, we will try resolving
        // the dependency and throw if it's not possible. We can
        // skip the check here.
        return;
      }
      var dep = version === "*" ? name : "".concat(name, "@^").concat(version);
      var found = missingDependencies.all ? false : mapGetOr(depsCache, "".concat(name, " :: ").concat(dirname), function () {
        return has();
      });
      if (!found) {
        debugLog().missingDeps.add(dep);
      }
    }
  };
  var provider = factory(api, providerOptions, dirname);
  var providerName = provider.name || factory.name;
  if (typeof provider[methodName] !== "function") {
    throw new Error("The \"".concat(providerName, "\" provider doesn't support the \"").concat(method, "\" polyfilling method."));
  }
  if (Array.isArray(provider.polyfills)) {
    polyfillsNames = new Map(provider.polyfills.map(function (name, index) {
      return [name, index];
    }));
    filterPolyfills = provider.filterPolyfills;
  } else if (provider.polyfills) {
    polyfillsNames = new Map(Object.keys(provider.polyfills).map(function (name, index) {
      return [name, index];
    }));
    polyfillsSupport = provider.polyfills;
    filterPolyfills = provider.filterPolyfills;
  } else {
    polyfillsNames = new Map();
  }
  var _validateIncludeExclu = validateIncludeExclude(providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);
  include = _validateIncludeExclu.include;
  exclude = _validateIncludeExclu.exclude;
  var callProvider;
  if (methodName === "usageGlobal") {
    callProvider = function callProvider(payload, path) {
      var _ref;
      var utils = getUtils(path);
      return (_ref = provider[methodName](payload, utils, path)) != null ? _ref : false;
    };
  } else {
    callProvider = function callProvider(payload, path) {
      var utils = getUtils(path);
      provider[methodName](payload, utils, path);
      return false;
    };
  }
  return {
    debug: _debug,
    method: method,
    targets: targets,
    provider: provider,
    providerName: providerName,
    callProvider: callProvider
  };
}
function definePolyfillProvider(factory) {
  return (0, _helperPluginUtils.declare)(function (babelApi, options, dirname) {
    babelApi.assertVersion("^7.0.0 || ^8.0.0-alpha.0");
    var traverse = babelApi.traverse;
    var debugLog;
    var missingDependencies = applyMissingDependenciesDefaults(options, babelApi);
    var _instantiateProvider = instantiateProvider(factory, options, missingDependencies, dirname, function () {
        return debugLog;
      }, babelApi),
      debug = _instantiateProvider.debug,
      method = _instantiateProvider.method,
      targets = _instantiateProvider.targets,
      provider = _instantiateProvider.provider,
      providerName = _instantiateProvider.providerName,
      callProvider = _instantiateProvider.callProvider;
    var createVisitor = method === "entry-global" ? entry : usage;
    var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);
    if (debug && debug !== presetEnvSilentDebugHeader) {
      console.log("".concat(providerName, ": `DEBUG` option"));
      console.log("\nUsing targets: ".concat(stringifyTargetsMultiline(targets)));
      console.log("\nUsing polyfills with `".concat(method, "` method:"));
    }
    var runtimeName = provider.runtimeName;
    return {
      name: "inject-polyfills",
      visitor: visitor,
      pre: function pre(file) {
        var _provider$pre;
        if (runtimeName) {
          if (file.get("runtimeHelpersModuleName") && file.get("runtimeHelpersModuleName") !== runtimeName) {
            console.warn("Two different polyfill providers" + " (".concat(file.get("runtimeHelpersModuleProvider")) + " and ".concat(providerName, ") are trying to define two") + " conflicting @babel/runtime alternatives:" + " ".concat(file.get("runtimeHelpersModuleName"), " and ").concat(runtimeName, ".") + " The second one will be ignored.");
          } else {
            file.set("runtimeHelpersModuleName", runtimeName);
            file.set("runtimeHelpersModuleProvider", providerName);
          }
        }
        debugLog = {
          polyfills: new Set(),
          polyfillsSupport: undefined,
          found: false,
          providers: new Set(),
          missingDeps: new Set()
        };
        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
      },
      post: function post() {
        var _provider$post;
        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);
        if (missingDependencies !== false) {
          if (missingDependencies.log === "per-file") {
            logMissing(debugLog.missingDeps);
          } else {
            laterLogMissing(debugLog.missingDeps);
          }
        }
        if (!debug) return;
        if (this.filename) console.log("\n[".concat(this.filename, "]"));
        if (debugLog.polyfills.size === 0) {
          console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the ".concat(providerName, " polyfill did not add any polyfill.") : "The entry point for the ".concat(providerName, " polyfill has not been found.") : "Based on your code and targets, the ".concat(providerName, " polyfill did not add any polyfill."));
          return;
        }
        if (method === "entry-global") {
          console.log("The ".concat(providerName, " polyfill entry has been replaced with ") + "the following polyfills:");
        } else {
          console.log("The ".concat(providerName, " polyfill added the following polyfills:"));
        }
        var _iterator4 = _createForOfIteratorHelper(debugLog.polyfills),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var name = _step4.value;
            var _debugLog$polyfillsSu2;
            if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {
              var filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, debugLog.polyfillsSupport);
              var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
              console.log("  ".concat(name, " ").concat(formattedTargets));
            } else {
              console.log("  ".concat(name));
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    };
  });
}
function mapGetOr(map, key, getDefault) {
  var val = map.get(key);
  if (val === undefined) {
    val = getDefault();
    map.set(key, val);
  }
  return val;
}
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
var _default = exports["default"] = definePolyfillProvider;