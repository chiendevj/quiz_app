"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
exports.__esModule = true;
exports["default"] = definePolyfillProvider;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperCompilationTargets = _interopRequireWildcard(require("@babel/helper-compilation-targets"));
var _utils = require("./utils");
var _importsInjector = _interopRequireDefault(require("./imports-injector"));
var _debugUtils = require("./debug-utils");
var _normalizeOptions = require("./normalize-options");
var v = _interopRequireWildcard(require("./visitors"));
var deps = _interopRequireWildcard(require("./node/dependencies"));
var _metaResolver = _interopRequireDefault(require("./meta-resolver"));
var _excluded = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj["default"] = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var getTargets = _helperCompilationTargets["default"]["default"] || _helperCompilationTargets["default"];
function resolveOptions(options, babelApi) {
  var method = options.method,
    targetsOption = options.targets,
    ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
    configPath = options.configPath,
    debug = options.debug,
    shouldInjectPolyfill = options.shouldInjectPolyfill,
    absoluteImports = options.absoluteImports,
    providerOptions = _objectWithoutPropertiesLoose(options, _excluded);
  if (isEmpty(options)) {
    throw new Error("This plugin requires options, for example:\n    {\n      \"plugins\": [\n        [\"<plugin name>\", { method: \"usage-pure\" }]\n      ]\n    }\n\nSee more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md");
  }
  var methodName;
  if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
    throw new Error(".method must be a string");
  } else {
    throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + " or \"usage-pure\" (received ".concat(JSON.stringify(method), ")"));
  }
  if (typeof shouldInjectPolyfill === "function") {
    if (options.include || options.exclude) {
      throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
    }
  } else if (shouldInjectPolyfill != null) {
    throw new Error(".shouldInjectPolyfill must be a function, or undefined" + " (received ".concat(JSON.stringify(shouldInjectPolyfill), ")"));
  }
  if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
    throw new Error(".absoluteImports must be a boolean, a string, or undefined" + " (received ".concat(JSON.stringify(absoluteImports), ")"));
  }
  var targets;
  if (
  // If any browserslist-related option is specified, fallback to the old
  // behavior of not using the targets specified in the top-level options.
  targetsOption || configPath || ignoreBrowserslistConfig) {
    var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
      browsers: targetsOption
    } : targetsOption;
    targets = getTargets(targetsObj, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath
    });
  } else {
    targets = babelApi.targets();
  }
  return {
    method: method,
    methodName: methodName,
    targets: targets,
    absoluteImports: absoluteImports != null ? absoluteImports : false,
    shouldInjectPolyfill: shouldInjectPolyfill,
    debug: !!debug,
    providerOptions: providerOptions
  };
}
function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
  var _resolveOptions = resolveOptions(options, babelApi),
    method = _resolveOptions.method,
    methodName = _resolveOptions.methodName,
    targets = _resolveOptions.targets,
    _debug = _resolveOptions.debug,
    _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
    providerOptions = _resolveOptions.providerOptions,
    absoluteImports = _resolveOptions.absoluteImports;

  // eslint-disable-next-line prefer-const
  var include, exclude;
  var polyfillsSupport;
  var polyfillsNames;
  var filterPolyfills;
  var getUtils = (0, _utils.createUtilsGetter)(new _importsInjector["default"](function (moduleName) {
    return deps.resolve(dirname, moduleName, absoluteImports);
  }, function (name) {
    var _polyfillsNames$get, _polyfillsNames;
    return (_polyfillsNames$get = (_polyfillsNames = polyfillsNames) == null ? void 0 : _polyfillsNames.get(name)) != null ? _polyfillsNames$get : Infinity;
  }));
  var depsCache = new Map();
  var api = {
    babel: babelApi,
    getUtils: getUtils,
    method: options.method,
    targets: targets,
    createMetaResolver: _metaResolver["default"],
    shouldInjectPolyfill: function shouldInjectPolyfill(name) {
      if (polyfillsNames === undefined) {
        throw new Error("Internal error in the ".concat(factory.name, " provider: ") + "shouldInjectPolyfill() can't be called during initialization.");
      }
      if (!polyfillsNames.has(name)) {
        console.warn("Internal error in the ".concat(providerName, " provider: ") + "unknown polyfill \"".concat(name, "\"."));
      }
      if (filterPolyfills && !filterPolyfills(name)) return false;
      var shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {
        compatData: polyfillsSupport,
        includes: include,
        excludes: exclude
      });
      if (_shouldInjectPolyfill) {
        shouldInject = _shouldInjectPolyfill(name, shouldInject);
        if (typeof shouldInject !== "boolean") {
          throw new Error(".shouldInjectPolyfill must return a boolean.");
        }
      }
      return shouldInject;
    },
    debug: function debug(name) {
      var _debugLog, _debugLog$polyfillsSu;
      debugLog().found = true;
      if (!_debug || !name) return;
      if (debugLog().polyfills.has(providerName)) return;
      debugLog().polyfills.add(name);
      (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;
    },
    assertDependency: function assertDependency(name) {
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
      if (missingDependencies === false) return;
      if (absoluteImports) {
        // If absoluteImports is not false, we will try resolving
        // the dependency and throw if it's not possible. We can
        // skip the check here.
        return;
      }
      var dep = version === "*" ? name : "".concat(name, "@^").concat(version);
      var found = missingDependencies.all ? false : mapGetOr(depsCache, "".concat(name, " :: ").concat(dirname), function () {
        return deps.has(dirname, name);
      });
      if (!found) {
        debugLog().missingDeps.add(dep);
      }
    }
  };
  var provider = factory(api, providerOptions, dirname);
  var providerName = provider.name || factory.name;
  if (typeof provider[methodName] !== "function") {
    throw new Error("The \"".concat(providerName, "\" provider doesn't support the \"").concat(method, "\" polyfilling method."));
  }
  if (Array.isArray(provider.polyfills)) {
    polyfillsNames = new Map(provider.polyfills.map(function (name, index) {
      return [name, index];
    }));
    filterPolyfills = provider.filterPolyfills;
  } else if (provider.polyfills) {
    polyfillsNames = new Map(Object.keys(provider.polyfills).map(function (name, index) {
      return [name, index];
    }));
    polyfillsSupport = provider.polyfills;
    filterPolyfills = provider.filterPolyfills;
  } else {
    polyfillsNames = new Map();
  }
  var _ref2 = (0, _normalizeOptions.validateIncludeExclude)(providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);
  include = _ref2.include;
  exclude = _ref2.exclude;
  var callProvider;
  if (methodName === "usageGlobal") {
    callProvider = function callProvider(payload, path) {
      var _ref;
      var utils = getUtils(path);
      return (_ref = provider[methodName](payload, utils, path)) != null ? _ref : false;
    };
  } else {
    callProvider = function callProvider(payload, path) {
      var utils = getUtils(path);
      provider[methodName](payload, utils, path);
      return false;
    };
  }
  return {
    debug: _debug,
    method: method,
    targets: targets,
    provider: provider,
    providerName: providerName,
    callProvider: callProvider
  };
}
function definePolyfillProvider(factory) {
  return (0, _helperPluginUtils.declare)(function (babelApi, options, dirname) {
    babelApi.assertVersion("^7.0.0 || ^8.0.0-alpha.0");
    var traverse = babelApi.traverse;
    var debugLog;
    var missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);
    var _instantiateProvider = instantiateProvider(factory, options, missingDependencies, dirname, function () {
        return debugLog;
      }, babelApi),
      debug = _instantiateProvider.debug,
      method = _instantiateProvider.method,
      targets = _instantiateProvider.targets,
      provider = _instantiateProvider.provider,
      providerName = _instantiateProvider.providerName,
      callProvider = _instantiateProvider.callProvider;
    var createVisitor = method === "entry-global" ? v.entry : v.usage;
    var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);
    if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {
      console.log("".concat(providerName, ": `DEBUG` option"));
      console.log("\nUsing targets: ".concat((0, _debugUtils.stringifyTargetsMultiline)(targets)));
      console.log("\nUsing polyfills with `".concat(method, "` method:"));
    }
    var runtimeName = provider.runtimeName;
    return {
      name: "inject-polyfills",
      visitor: visitor,
      pre: function pre(file) {
        var _provider$pre;
        if (runtimeName) {
          if (file.get("runtimeHelpersModuleName") && file.get("runtimeHelpersModuleName") !== runtimeName) {
            console.warn("Two different polyfill providers" + " (".concat(file.get("runtimeHelpersModuleProvider")) + " and ".concat(providerName, ") are trying to define two") + " conflicting @babel/runtime alternatives:" + " ".concat(file.get("runtimeHelpersModuleName"), " and ").concat(runtimeName, ".") + " The second one will be ignored.");
          } else {
            file.set("runtimeHelpersModuleName", runtimeName);
            file.set("runtimeHelpersModuleProvider", providerName);
          }
        }
        debugLog = {
          polyfills: new Set(),
          polyfillsSupport: undefined,
          found: false,
          providers: new Set(),
          missingDeps: new Set()
        };
        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
      },
      post: function post() {
        var _provider$post;
        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);
        if (missingDependencies !== false) {
          if (missingDependencies.log === "per-file") {
            deps.logMissing(debugLog.missingDeps);
          } else {
            deps.laterLogMissing(debugLog.missingDeps);
          }
        }
        if (!debug) return;
        if (this.filename) console.log("\n[".concat(this.filename, "]"));
        if (debugLog.polyfills.size === 0) {
          console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the ".concat(providerName, " polyfill did not add any polyfill.") : "The entry point for the ".concat(providerName, " polyfill has not been found.") : "Based on your code and targets, the ".concat(providerName, " polyfill did not add any polyfill."));
          return;
        }
        if (method === "entry-global") {
          console.log("The ".concat(providerName, " polyfill entry has been replaced with ") + "the following polyfills:");
        } else {
          console.log("The ".concat(providerName, " polyfill added the following polyfills:"));
        }
        var _iterator = _createForOfIteratorHelper(debugLog.polyfills),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var name = _step.value;
            var _debugLog$polyfillsSu2;
            if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {
              var filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, debugLog.polyfillsSupport);
              var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
              console.log("  ".concat(name, " ").concat(formattedTargets));
            } else {
              console.log("  ".concat(name));
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    };
  });
}
function mapGetOr(map, key, getDefault) {
  var val = map.get(key);
  if (val === undefined) {
    val = getDefault();
    map.set(key, val);
  }
  return val;
}
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}